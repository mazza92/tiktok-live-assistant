<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TikTok Live Dashboard</title>
    <style>
        :root {
            --animation-duration: 0.5s;
            --transition-duration: 0.3s;
            --shadow-intensity: 0.15;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow-x: hidden;
        }

        /* Language Switcher Styles */
        .language-switcher {
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .language-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .language-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .language-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        /* Header Layout Styles */
        .header-top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 20px;
        }

        .header-top-row h1 {
            margin: 0;
            flex: 1;
        }

        .language-switcher {
            flex-shrink: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px 30px 30px 30px;
        }



        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 40px;
        }

        /* Mobile responsive layout */
        @media (max-width: 768px) {
            .header-top-row {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .language-switcher {
                padding: 6px;
            }
            
            .language-btn {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
            
            :root {
                --animation-duration: 0.3s;
                --transition-duration: 0.2s;
                --shadow-intensity: 0.1;
            }
            
            .container {
                padding: 15px;
                margin: 10px;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
                gap: 15px;
                margin-bottom: 30px;
            }
            
            .dashboard-header {
                padding: 20px;
            }
            
            .dashboard-header h1 {
                font-size: 2.2rem;
            }
            
            .username-section {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }
            
            .username-input-container {
                flex-direction: column;
                gap: 10px;
            }
            
            .username-input-container input {
                width: 100%;
                text-align: center;
            }
            
            .username-input-container button {
                width: 100%;
                padding: 12px;
                font-size: 1rem;
            }
            
            .current-stream-info {
                text-align: center;
                flex-direction: column;
                gap: 10px;
            }
            
            .question-highlight {
                margin: 20px 0;
            }
            
            .question-stats-bar {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
                padding: 15px;
            }
            
            .question-slideshow {
                margin: 20px 0;
            }
            
            .question-card {
                padding: 20px;
            }
            
            .card-actions {
                flex-direction: column;
                gap: 10px;
            }
            
            /* Mobile performance optimizations */
            .metric-card, .entertainment-gauge, .question-card {
                box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
                backdrop-filter: none !important;
            }
            
            /* Reduce animation complexity on mobile */
            .metric-trend.increase, .metric-trend.decrease, .metric-trend.stable {
                animation: none !important;
            }
            
            /* Disable heavy gradients on mobile */
            .entertainment-gauge::before {
                animation: none !important;
            }
            
            /* Optimize transitions for mobile */
            * {
                transition-duration: var(--transition-duration) !important;
            }
            
            .action-btn-large {
                width: 100%;
                padding: 15px;
                font-size: 1rem;
            }
            
            .viewer-stats-section {
                margin: 20px 0;
            }
            
            .viewer-stats-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .ai-insights {
                margin: 20px 0;
            }
            
            .actionable-prompt {
                margin: 20px 0;
            }
            
            .feed-header {
                font-size: 1.2rem;
                padding: 15px;
            }
            
            .feed-item {
                padding: 15px;
                margin-bottom: 10px;
            }
        }

        /* Tablet responsive layout */
        @media (min-width: 769px) and (max-width: 1024px) {
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 18px;
            }
        }

        .metric-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 30px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            min-height: 150px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        /* Responsive adjustments for metric cards */
        @media (max-width: 768px) {
            .metric-card {
                padding: 20px;
                min-height: 120px;
            }
            
            .metric-value {
                font-size: 2rem;
                margin-bottom: 10px;
            }
            
            .metric-label {
                font-size: 1rem;
                letter-spacing: 1px;
            }
            
            .metric-subtitle {
                font-size: 0.8rem;
                margin-top: 3px;
            }
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .metric-card:hover::before {
            left: 100%;
        }

        .metric-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 12px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            display: block;
            transition: all 0.3s ease;
            position: relative;
        }

        .metric-value.updated {
            animation: valueUpdate 0.6s ease-out;
        }

        @keyframes valueUpdate {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); color: #ffed4e; }
            100% { transform: scale(1); }
        }

        .metric-label {
            font-size: 1.1rem;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 600;
        }

        .metric-subtitle {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-top: 5px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.8);
        }

        .metric-trend {
            position: absolute;
            top: 18px;
            right: 18px;
            width: 32px;
            height: 32px;
            transition: all 0.3s ease;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 50%;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Responsive adjustments for trend indicators */
        @media (max-width: 768px) {
            .metric-trend {
                width: 24px;
                height: 24px;
                top: 12px;
                right: 12px;
            }
        }

        .metric-trend svg {
            width: 100%;
            height: 100%;
            transition: all 0.3s ease;
        }

        .metric-trend.increase {
            color: #00E676;
            animation: pulseGreen 1.5s ease-in-out infinite;
            transform: scale(1.1);
        }

        .metric-trend.increase svg {
            filter: drop-shadow(0 0 12px rgba(0, 230, 118, 0.6));
            animation: glowGreen 2s ease-in-out infinite;
        }

        .metric-trend.decrease {
            color: #FF5252;
            animation: pulseRed 1.5s ease-in-out infinite;
            transform: scale(1.1);
        }

        .metric-trend.decrease svg {
            filter: drop-shadow(0 0 12px rgba(255, 82, 82, 0.6));
            animation: glowRed 2s ease-in-out infinite;
        }

        .metric-trend.stable {
            color: #FFD700;
            opacity: 0.9;
            animation: pulseStable 2s ease-in-out infinite;
        }

        .metric-trend.stable svg {
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.5));
        }

        .metric-trend:hover {
            transform: scale(1.2);
            transition: transform 0.3s ease;
        }

        .metric-trend.increase:hover {
            animation: pulseGreen 0.8s ease-in-out infinite;
        }

        .metric-trend.decrease:hover {
            animation: pulseRed 0.8s ease-in-out infinite;
        }

        .metric-trend.stable:hover {
            animation: pulseStable 1s ease-in-out infinite;
        }

        .metric-trend.increase:hover svg {
            filter: drop-shadow(0 0 20px rgba(0, 230, 118, 0.8));
        }

        .metric-trend.decrease:hover svg {
            filter: drop-shadow(0 0 20px rgba(255, 82, 82, 0.8));
        }

        .metric-trend.stable:hover svg {
            filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.7));
        }

        @keyframes pulseGreen {
            0% { transform: scale(1); opacity: 0.8; }
            25% { transform: scale(1.1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 1; }
            75% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        @keyframes pulseRed {
            0% { transform: scale(1); opacity: 0.8; }
            25% { transform: scale(1.1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 1; }
            75% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        @keyframes pulseStable {
            0%, 100% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.05); opacity: 1; }
        }

        @keyframes glowGreen {
            0%, 100% { filter: drop-shadow(0 0 12px rgba(0, 230, 118, 0.6)); }
            50% { filter: drop-shadow(0 0 20px rgba(0, 230, 118, 0.9)); }
        }

        @keyframes glowRed {
            0%, 100% { filter: drop-shadow(0 0 12px rgba(255, 82, 82, 0.6)); }
            50% { filter: drop-shadow(0 0 20px rgba(255, 82, 82, 0.9)); }
        }
        
        /* Viewer Stats Cards */
        .viewer-stat-card {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .viewer-stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .viewer-stat-card .stat-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .viewer-stat-card .stat-label {
            font-size: 1rem;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .viewer-stat-card .stat-subtitle {
            font-size: 0.8rem;
            opacity: 0.7;
            font-style: italic;
        }

        /* Green Lights Effect for Session Followers (Never Decreases) */
        .metric-card:has(#followersGains) .metric-value {
            position: relative;
            transition: all 0.3s ease;
        }

        .metric-card:has(#followersGains) .metric-value.green-glow {
            color: #00E676;
            text-shadow: 
                0 0 10px rgba(0, 230, 118, 0.8),
                0 0 20px rgba(0, 230, 118, 0.6),
                0 0 30px rgba(0, 230, 118, 0.4);
            animation: followersGlow 2s ease-in-out;
        }

        @keyframes followersGlow {
            0% { 
                transform: scale(1);
                text-shadow: 
                    0 0 10px rgba(0, 230, 118, 0.8),
                    0 0 20px rgba(0, 230, 118, 0.6),
                    0 0 30px rgba(0, 230, 118, 0.4);
            }
            25% { 
                transform: scale(1.05);
                text-shadow: 
                    0 0 15px rgba(0, 230, 118, 1),
                    0 0 25px rgba(0, 230, 118, 0.8),
                    0 0 35px rgba(0, 230, 118, 0.6);
            }
            50% { 
                transform: scale(1.1);
                text-shadow: 
                    0 0 20px rgba(0, 230, 118, 1),
                    0 0 30px rgba(0, 230, 118, 0.9),
                    0 0 40px rgba(0, 230, 118, 0.7);
            }
            75% { 
                transform: scale(1.05);
                text-shadow: 
                    0 0 15px rgba(0, 230, 118, 1),
                    0 0 25px rgba(0, 230, 118, 0.8),
                    0 0 35px rgba(0, 230, 118, 0.6);
            }
            100% { 
                transform: scale(1);
                text-shadow: 
                    0 0 10px rgba(0, 230, 118, 0.8),
                    0 0 20px rgba(0, 230, 118, 0.6),
                    0 0 30px rgba(0, 230, 118, 0.4);
            }
        }

        /* Enhanced Followers Gains Card */
        .metric-card:has(#followersGains) {
            background: linear-gradient(135deg, rgba(0, 230, 118, 0.1) 0%, rgba(0, 230, 118, 0.05) 100%);
            border: 1px solid rgba(0, 230, 118, 0.3);
            position: relative;
            overflow: hidden;
        }

        .metric-card:has(#followersGains)::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, 
                transparent 0%, 
                rgba(0, 230, 118, 0.1) 25%, 
                transparent 50%, 
                rgba(0, 230, 118, 0.1) 75%, 
                transparent 100%);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }

        .metric-card:has(#followersGains).shimmer::before {
            transform: translateX(100%);
        }

        .viewer-stats-section {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .viewer-stats-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border-radius: 24px;
        }

        .viewer-stats-section h2 {
            margin: 0 0 25px 0;
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 2;
        }

        .viewer-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .viewer-stat-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            z-index: 2;
        }

        .viewer-stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
        }

        .viewer-stat-card .stat-value {
            font-size: 32px;
            font-weight: 800;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .viewer-stat-card .stat-label {
            font-size: 14px;
            font-weight: 500;
            opacity: 0.9;
            margin-bottom: 4px;
        }
        
        .viewer-stat-card .stat-subtitle {
            font-size: 11px;
            font-weight: 400;
            opacity: 0.7;
            font-style: italic;
        }



        /* Gift Alert Overlay Styles */
        .gift-alert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            animation: fadeIn 0.3s ease-out;
        }

        .gift-alert-overlay.hidden {
            display: none;
        }

        .gift-alert-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 25px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            animation: slideInUp 0.4s ease-out;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .gift-alert-header {
            margin-bottom: 25px;
        }

        .gift-icon {
            font-size: 48px;
            display: block;
            margin-bottom: 10px;
            animation: bounce 2s infinite;
        }

        .gift-title {
            font-size: 28px;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .gift-counter-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .gift-alert-body {
            margin-bottom: 30px;
        }

        .gift-sender {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            gap: 15px;
        }

        .gift-sender-pic {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            object-fit: cover;
        }

        .gift-sender-name {
            font-size: 24px;
            font-weight: 600;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .gift-details {
            margin-bottom: 20px;
        }

        .gift-name {
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .gift-value {
            font-size: 18px;
            color: #ffd700;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .ai-prompt {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .ai-prompt-text {
            font-size: 16px;
            color: #ffffff;
            line-height: 1.5;
            font-style: italic;
        }

        .gift-alert-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .gift-action-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .shoutout-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .shoutout-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
        }

        .thank-btn {
            background: linear-gradient(135deg, #6bcf7f, #4ecdc4);
            color: white;
            box-shadow: 0 4px 15px rgba(107, 207, 127, 0.4);
        }

        .thank-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(107, 207, 127, 0.6);
        }

        .close-btn {
            background: rgba(255, 255, 255, 0.2);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .emergency-btn {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
            font-weight: bold;
        }
        
        .emergency-btn:hover {
            background: linear-gradient(135deg, #c82333, #a71e2a);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.6);
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }

        /* Streamer Welcome Alert Styles */
        .streamer-welcome-alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            border-radius: 25px;
            padding: 35px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            animation: pulseIn 0.6s ease-out;
            border: 3px solid rgba(255, 255, 255, 0.3);
            z-index: 9999;
            text-align: center;
        }

        .alert-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .alert-icon {
            font-size: 32px;
            animation: bounce 1.5s infinite;
        }

        .alert-title {
            font-size: 24px;
            font-weight: 800;
            color: #ffffff;
            text-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
            letter-spacing: 1px;
        }

        .alert-body {
            margin-bottom: 20px;
        }

        .alert-viewer {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .alert-viewer-pic {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.4);
            object-fit: cover;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .alert-viewer-name {
            font-size: 22px;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .alert-message {
            font-size: 20px;
            color: #ffffff;
            margin-bottom: 20px;
            line-height: 1.4;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .alert-tip {
            font-size: 16px;
            color: #ffffff;
            line-height: 1.4;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .alert-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: #ffffff;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .alert-close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        @keyframes pulseIn {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.05);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-8px);
            }
            60% {
                transform: translateY(-4px);
            }
        }

        /* Performance Monitor Styles */
        .performance-monitor {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .performance-monitor h3 {
            color: white;
            margin: 0 0 15px 0;
            font-size: 18px;
            text-align: center;
        }
        
        .performance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .perf-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .perf-label {
            display: block;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .perf-value {
            display: block;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        
        .perf-refresh-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .perf-refresh-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        


        .entertainment-gauge {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1) 0%, rgba(255, 193, 7, 0.08) 100%);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 35px;
            text-align: center;
            margin: 30px 0;
            border: 2px solid rgba(255, 107, 107, 0.25);
            box-shadow: 
                0 20px 40px rgba(255, 107, 107, 0.15),
                0 8px 25px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .entertainment-gauge:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 25px 50px rgba(255, 107, 107, 0.2),
                0 12px 30px rgba(0, 0, 0, 0.15);
        }

        .entertainment-gauge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #ff6b6b, #ffc107, #ff6b6b);
            animation: gaugeGlow 3s ease-in-out infinite;
        }

        @keyframes gaugeGlow {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .sentiment-gauge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border-radius: 24px;
        }

        .entertainment-gauge h3 {
            margin: 0 0 20px 0;
            font-size: 1.6rem;
            color: #ffffff;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .entertainment-gauge h3::before {
            content: '🔴';
            font-size: 1.8rem;
            filter: drop-shadow(0 2px 4px rgba(255, 0, 0, 0.3));
            animation: moodPulse 2s ease-in-out infinite;
            color: #ff0000;
            -webkit-text-fill-color: initial;
            background: none;
            -webkit-background-clip: initial;
            background-clip: initial;
        }

        @keyframes moodPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        .gauge-container {
            width: 160px;
            height: 80px;
            margin: 0 auto 20px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2;
        }

        .gauge {
            width: 100%;
            height: 100%;
            border-radius: 80px 80px 0 0;
            background: conic-gradient(
                #ff6b6b 0deg,
                #ffd93d 45deg,
                #6bcf7f 90deg,
                #6bcf7f 180deg
            );
            position: relative;
            transform: rotate(-90deg);
            box-shadow: inset 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        .gauge::before {
            content: '';
            position: absolute;
            width: 80%;
            height: 80%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.7) 100%);
            border-radius: 64px 64px 0 0;
            top: 10%;
            left: 10%;
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .gauge-needle {
            position: absolute;
            width: 3px;
            height: 40px;
            background: linear-gradient(to top, #2c3e50, #34495e);
            bottom: 0;
            left: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(0deg);
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            border-radius: 2px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .gauge-needle::after {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 6px solid #2c3e50;
        }

        /* Main Entertainment Score Display */
        .entertainment-main {
            margin-bottom: 25px;
        }

        .score-display {
            margin-bottom: 25px;
        }

        .score-number {
            font-size: 3.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #ff6b6b, #ffd93d, #6bcf7f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: none;
        }

        .score-label {
            font-size: 1.2rem;
            color: #ffffff;
            font-weight: 600;
            margin-bottom: 20px;
        }

        /* Progress Bar Container */
        .progress-container {
            margin: 0 auto;
            max-width: 400px;
        }

        .progress-bar {
            position: relative;
            height: 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ffd93d, #6bcf7f);
            border-radius: 8px;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            width: 0%;
            position: relative;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Progress Markers */
        .progress-markers {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            pointer-events: none;
        }

        .marker {
            font-size: 1.4rem;
            transition: all 0.3s ease;
            text-align: center;
            flex: 1;
            position: relative;
        }

        .marker.active {
            transform: scale(1.3);
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.6));
            z-index: 2;
        }

        .marker.boring { color: #9E9E9E; }
        .marker.meh { color: #FF9800; }
        .marker.good { color: #8BC34A; }
        .marker.entertaining { color: #4CAF50; }
        .marker.fire { color: #ff4444; }

        /* Progress Labels */
        .progress-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 8px;
        }

        .progress-labels span {
            flex: 1;
            text-align: center;
            transition: color 0.3s ease;
        }

        .progress-labels span:hover {
            color: rgba(255, 255, 255, 1);
        }

        .entertainment-breakdown {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Mobile responsive entertainment breakdown */
        @media (max-width: 768px) {
            .entertainment-breakdown {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
            }
        }
        
        @media (max-width: 480px) {
            .entertainment-breakdown {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
            
            .breakdown-item {
                padding: 12px 8px;
            }
            
            .breakdown-icon {
                font-size: 1.3rem;
            }
            
            .breakdown-label {
                font-size: 0.65rem;
            }
            
            .breakdown-value {
                font-size: 0.9rem;
            }
        }

        .breakdown-item {
            text-align: center;
            padding: 18px 12px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .breakdown-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s ease;
        }

        .breakdown-item:hover::before {
            left: 100%;
        }

        .breakdown-icon {
            font-size: 1.8rem;
            margin-bottom: 10px;
            opacity: 1;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
            transition: all 0.3s ease;
        }

        .breakdown-item:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.18) 0%, rgba(255, 255, 255, 0.1) 100%);
            transform: translateY(-3px) scale(1.02);
            border-color: rgba(255, 107, 107, 0.4);
            box-shadow: 0 12px 25px rgba(255, 107, 107, 0.2);
        }

        .breakdown-item:hover .breakdown-icon {
            transform: scale(1.1);
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        .breakdown-label {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            transition: color 0.3s ease;
        }

        .breakdown-item:hover .breakdown-label {
            color: #ffffff;
        }

        .breakdown-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .breakdown-item:hover .breakdown-value {
            color: #ffed4e;
            text-shadow: 0 4px 8px rgba(255, 237, 78, 0.4);
        }

        .entertainment-score {
            font-size: 2.5rem;
            font-weight: 800;
            color: #ffffff;
            margin: 15px 0 10px;
            display: block;
            transition: all 0.4s ease;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 2;
        }

        .entertainment-label {
            font-size: 1.1rem;
            color: #ffffff;
            margin: 0;
            font-weight: 600;
            text-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 2;
            letter-spacing: 0.5px;
        }

        .entertainment-scale {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 15px;
            letter-spacing: 1px;
            font-weight: 500;
            text-transform: uppercase;
            position: relative;
            z-index: 2;
        }

        /* Add subtle animation to the gauge */
        .gauge-container:hover .gauge {
            transform: rotate(-90deg) scale(1.02);
            transition: transform 0.3s ease;
        }

        /* Add glow effect to the score */
        .entertainment-score:hover {
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
        }

        /* Add pulse animation for the gauge */
        @keyframes gaugePulse {
            0% { box-shadow: 0 15px 30px rgba(255, 107, 107, 0.2); }
            50% { box-shadow: 0 15px 30px rgba(255, 107, 107, 0.4), 0 0 20px rgba(255, 107, 107, 0.2); }
            100% { box-shadow: 0 15px 30px rgba(255, 107, 107, 0.2); }
        }

        .entertainment-gauge {
            animation: gaugePulse 3s ease-in-out infinite;
        }

        /* Add floating animation for the needle */
        @keyframes needleFloat {
            0%, 100% { transform: translateX(-50%) rotate(var(--rotation)) translateY(0px); }
            50% { transform: translateX(-50%) rotate(var(--rotation)) translateY(-2px); }
        }

        .gauge-needle {
            animation: needleFloat 2s ease-in-out infinite;
        }

        /* Add gradient text effect for the title */
        .entertainment-gauge h3 {
            background: linear-gradient(45deg, #ffffff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Add modern card effect */
        .entertainment-gauge {
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Add smooth transitions for all gauge elements */
        .gauge-container * {
            transition: all 0.3s ease;
        }

        /* Improve gauge responsiveness */
        @media (max-width: 768px) {
            .gauge-container {
                width: 120px;
                height: 60px;
            }
            
            .entertainment-score {
                font-size: 1.8rem;
            }
            
            .entertainment-gauge h3 {
                font-size: 1.2rem;
            }

            .progress-container {
                max-width: 300px;
            }

            .marker {
                font-size: 1.2rem;
            }

            .progress-labels {
                font-size: 0.65rem;
            }
        }



        .prompt-text {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 25px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            line-height: 1.3;
            max-width: 90%;
        }
        
        .high-priority {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            border: 2px solid #ff4757;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.4);
            border-radius: 15px;
            padding: 20px;
        }
        
        .medium-priority {
            background: linear-gradient(135deg, #ffa726, #ff9800);
            border: 2px solid #ff9800;
            box-shadow: 0 0 20px rgba(255, 167, 38, 0.4);
            border-radius: 15px;
            padding: 20px;
        }
        
        .auto-prompt-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 0.9rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .auto-prompt-icon {
            font-size: 1.2rem;
        }
        
        .auto-prompt-type {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
        }
        
        .auto-prompt-priority {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
        }
        
        .auto-prompt-message {
            font-size: 1.3rem;
            margin-bottom: 10px;
        }
        
        .auto-prompt-trigger {
            font-size: 0.8rem;
            opacity: 0.8;
            font-style: italic;
        }

        .prompt-timestamp {
            font-size: 1rem;
            opacity: 0.8;
            font-weight: 500;
            letter-spacing: 1px;
        }

        .no-prompt {
            font-size: 1.4rem;
            opacity: 0.7;
            font-style: italic;
            color: #ccc;
        }

        .activity-feed {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            border-radius: 25px;
            padding: 35px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
        }

        .activity-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 15px;
        }

        .tab-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 8px 16px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab-btn.active {
            background: linear-gradient(45deg, #ff0050, #ff6b9d);
            border-color: transparent;
            box-shadow: 0 4px 15px rgba(255, 0, 80, 0.3);
        }

        .activity-summary {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .summary-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 5px;
        }

        .summary-icon {
            font-size: 1.5rem;
            opacity: 0.9;
        }

        .summary-count {
            font-size: 1.2rem;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .activity-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
            gap: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }

        .control-group select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #ffffff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .control-group select:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .control-btn.paused {
            background: rgba(255, 193, 7, 0.3);
            border-color: #ffc107;
            color: #ffc107;
        }
        
        .top-engagers {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            border-radius: 25px;
            padding: 35px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            margin-top: 30px;
        }
        
        .ai-insights {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            border-radius: 25px;
            padding: 35px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            margin-top: 30px;
        }

        .question-highlight {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.15), rgba(255, 193, 7, 0.15));
            backdrop-filter: blur(15px);
            border-radius: 25px;
            padding: 35px;
            border: 2px solid rgba(255, 107, 107, 0.3);
            box-shadow: 0 15px 35px rgba(255, 107, 107, 0.2);
            margin-top: 30px;
            position: relative;
            overflow: hidden;
        }

        .question-highlight::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #ff6b6b, #ffc107, #ff6b6b);
            animation: questionPulse 2s infinite;
        }

        @keyframes questionPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .question-stats-bar {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }

        .question-slideshow {
            position: relative;
            margin-top: 20px;
        }

        .slideshow-container {
            position: relative;
            min-height: 300px;
        }

        .question-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
            transition: all 0.4s ease;
            animation: cardGlow 2s infinite alternate;
        }

        @keyframes cardGlow {
            0% { box-shadow: 0 10px 30px rgba(255, 107, 107, 0.2); }
            100% { box-shadow: 0 15px 40px rgba(255, 193, 7, 0.3); }
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .question-priority-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .priority-5 { background: rgba(255, 68, 68, 0.3); color: #ff4444; border: 1px solid rgba(255, 68, 68, 0.5); }
        .priority-4 { background: rgba(255, 136, 0, 0.3); color: #ff8800; border: 1px solid rgba(255, 136, 0, 0.5); }
        .priority-3 { background: rgba(255, 170, 0, 0.3); color: #ffaa00; border: 1px solid rgba(255, 170, 0, 0.5); }
        .priority-2 { background: rgba(139, 195, 74, 0.3); color: #8BC34A; border: 1px solid rgba(139, 195, 74, 0.5); }
        .priority-1 { background: rgba(158, 158, 158, 0.3); color: #9E9E9E; border: 1px solid rgba(158, 158, 158, 0.5); }

        .question-timer {
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            color: #ffd700;
            font-weight: 500;
        }

        .question-content {
            margin-bottom: 30px;
        }

        .viewer-info {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }

        .viewer-icon {
            font-size: 1.5rem;
        }

        .viewer-name {
            font-size: 1.4rem;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .question-text {
            font-size: 1.6rem;
            line-height: 1.4;
            color: #ffffff;
            background: rgba(255, 255, 255, 0.05);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: 500;
        }

        .card-actions {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .action-btn-large {
            padding: 20px 30px;
            border: none;
            border-radius: 15px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 160px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .answer-btn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: 2px solid #4CAF50;
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }

        .answer-btn:hover {
            background: linear-gradient(135deg, #45a049, #4CAF50);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(76, 175, 80, 0.4);
        }

        .ignore-btn {
            background: linear-gradient(135deg, #9E9E9E, #757575);
            color: white;
            border: 2px solid #9E9E9E;
            box-shadow: 0 5px 15px rgba(158, 158, 158, 0.3);
        }

        .ignore-btn:hover {
            background: linear-gradient(135deg, #757575, #9E9E9E);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(158, 158, 158, 0.4);
        }

        .btn-icon {
            font-size: 1.5rem;
        }

        .btn-text {
            font-size: 0.9rem;
        }

        .auto-advance-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .indicator-text {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            font-style: italic;
            transition: color 0.3s ease;
            text-align: center;
        }
        
        .auto-advance-indicator .question-counter {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            color: #ffd700;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .question-counter {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            color: #ffd700;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }

        .stat-item {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 10px;
            font-weight: 500;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        /* Question Item Styles */
        .question-item {
            border-left-width: 4px;
            border-left-style: solid;
            margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }

        .question-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(5px);
        }

        .question-icon {
            margin-right: 8px;
            font-size: 1.1rem;
        }

        .question-nickname {
            font-weight: 600;
            color: #ffd700;
        }

        .question-priority {
            margin-left: 10px;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .priority-5 { background: rgba(255, 68, 68, 0.3); color: #ff4444; }
        .priority-4 { background: rgba(255, 136, 0, 0.3); color: #ff8800; }
        .priority-3 { background: rgba(255, 170, 0, 0.3); color: #ffaa00; }
        .priority-2 { background: rgba(139, 195, 74, 0.3); color: #8BC34A; }
        .priority-1 { background: rgba(158, 158, 158, 0.3); color: #9E9E9E; }

        .question-text {
            font-size: 0.95rem;
            line-height: 1.4;
            margin: 8px 0;
        }

        .question-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .answer-btn {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }

        .answer-btn:hover {
            background: rgba(76, 175, 80, 0.5);
            transform: translateY(-2px);
        }

        .ignore-btn {
            background: rgba(158, 158, 158, 0.3);
            color: #9E9E9E;
            border: 1px solid rgba(158, 158, 158, 0.5);
        }

        .ignore-btn:hover {
            background: rgba(158, 158, 158, 0.5);
            transform: translateY(-2px);
        }

        .answered-badge, .ignored-badge {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .answered-badge {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
        }

        .ignored-badge {
            background: rgba(158, 158, 158, 0.3);
            color: #9E9E9E;
        }

        .predictive-analytics {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            border-radius: 25px;
            padding: 35px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            margin-top: 30px;
        }

        .predictive-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .predictive-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .predictive-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            transition: all 0.3s ease;
        }

        .predictive-card.churn-risk::before {
            background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
        }

        .predictive-card.monetization::before {
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
        }

        .predictive-card.retention::before {
            background: linear-gradient(90deg, #45b7d1, #96ceb4);
        }

        .predictive-card.volatility::before {
            background: linear-gradient(90deg, #feca57, #ff9ff3);
        }

        .predictive-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.08);
        }

        .predictive-icon {
            font-size: 2.5rem;
            margin-bottom: 15px;
        }

        .predictive-title {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 10px;
            font-weight: 500;
        }

        .predictive-value {
            font-size: 2rem;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .predictive-trend {
            font-size: 0.8rem;
            padding: 4px 12px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }

        .predictive-insights {
            margin-top: 20px;
        }
        
        .actionable-prompt {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.08));
            backdrop-filter: blur(15px);
            border-radius: 25px;
            padding: 35px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            margin-top: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .actionable-prompt::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57);
            animation: rainbow 3s linear infinite;
        }
        
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }
        
        .prompt-content {
            text-align: center;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        .prompt-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        .prompt-text {
            font-size: 1.8rem;
            font-weight: bold;
            color: #fff;
            margin-bottom: 15px;
            line-height: 1.6;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            max-width: 90%;
            margin-left: auto;
            margin-right: auto;
            letter-spacing: 0.3px;
        }
        
        .prompt-trigger {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
            background: rgba(0, 0, 0, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-block;
        }
        
        /* Mobile-optimized actionable prompt layout */
        @media (max-width: 768px) {
            .actionable-prompt {
                padding: 30px 25px;
                margin: 20px 15px;
                border-radius: 20px;
            }
            
            .prompt-content {
                text-align: left;
                display: flex;
                flex-direction: column;
                gap: 20px;
            }
            
            .prompt-icon {
                font-size: 3rem;
                margin-bottom: 0;
                text-align: center;
                order: -1;
            }
            
            .prompt-text {
                font-size: 1.6rem;
                line-height: 1.8;
                margin-bottom: 0;
                text-align: left;
                max-width: 100%;
                word-wrap: break-word;
                hyphens: auto;
                padding: 0;
                letter-spacing: 0.5px;
            }
            
            .prompt-trigger {
                font-size: 0.9rem;
                padding: 10px 16px;
                text-align: center;
                width: 100%;
                margin-top: 0;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
        }
        
        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .actionable-prompt {
                padding: 25px 20px;
                margin: 15px 10px;
            }
            
            .prompt-content {
                gap: 18px;
            }
            
            .prompt-text {
                font-size: 1.4rem;
                line-height: 1.9;
                letter-spacing: 0.3px;
            }
            
            .prompt-icon {
                font-size: 2.5rem;
            }
            
            .prompt-trigger {
                font-size: 0.85rem;
                padding: 8px 14px;
            }
        }
        
        /* Very small mobile devices */
        @media (max-width: 360px) {
            .actionable-prompt {
                padding: 20px 15px;
                margin: 10px 5px;
            }
            
            .prompt-content {
                gap: 15px;
            }
            
            .prompt-text {
                font-size: 1.3rem;
                line-height: 2.0;
                letter-spacing: 0.2px;
            }
            
            .prompt-icon {
                font-size: 2.2rem;
            }
            
            .prompt-trigger {
                font-size: 0.8rem;
                padding: 6px 12px;
            }
        }
        
        .prompt-history {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            border-radius: 25px;
            padding: 35px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            margin-top: 30px;
        }
        
        .prompt-history .feed-item {
            display: flex;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .prompt-history .feed-item:last-child {
            border-bottom: none;
        }
        
        .prompt-history .feed-timestamp {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.5);
            margin-right: 15px;
            min-width: 80px;
        }
        
        .prompt-history .feed-content {
            flex-grow: 1;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .prompt-history .feed-trigger {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 12px;
            margin-left: 10px;
        }

        .feed-header {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.5rem;
            color: #ffd700;
            font-weight: 600;
            letter-spacing: 1px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .feed-item {
            background: rgba(255, 255, 255, 0.06);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid #ffd700;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .feed-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.05), transparent);
            transition: left 0.5s;
        }

        .feed-item:hover::before {
            left: 100%;
        }

        .feed-item:hover {
            transform: translateX(5px);
            background: rgba(255, 255, 255, 0.08);
            border-left-color: #ffed4e;
        }

        .feed-item:last-child {
            margin-bottom: 0;
        }

        .feed-user {
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 8px;
            font-size: 1.1rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .feed-header-row .feed-user {
            margin-bottom: 0;
        }

        .feed-content {
            opacity: 0.95;
            font-size: 1rem;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .feed-time {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-top: 8px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .feed-header-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .feed-type-icon {
            font-size: 1.2rem;
            opacity: 0.8;
        }

        .feed-sentiment {
            margin-top: 8px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .feed-sentiment.positive {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .feed-sentiment.negative {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .feed-sentiment.neutral {
            background: rgba(255, 152, 0, 0.2);
            color: #FF9800;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }

        .status-indicator {
            position: fixed;
            top: 25px;
            right: 25px;
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
        }

        .status-connected {
            background: linear-gradient(45deg, #44ff44, #00dd00);
            color: #000;
            border-color: rgba(68, 255, 68, 0.3);
        }

        .status-disconnected {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            color: #fff;
            border-color: rgba(255, 68, 68, 0.3);
        }

        .status-connecting {
            background: linear-gradient(45deg, #ffaa00, #ff8800);
            color: #000;
            border-color: rgba(255, 170, 0, 0.3);
        }

        .status-indicator:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4);
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header {
                padding: 30px 15px;
                margin-bottom: 30px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header p {
                font-size: 1.1rem;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .metric-card {
                padding: 25px;
            }
            
            .metric-value {
                font-size: 2.5rem;
            }
            
            .sentiment-gauge {
                padding: 30px 20px;
            }
            
            .gauge-container {
                width: 160px;
                height: 80px;
            }
            
            .sentiment-score {
                font-size: 2.5rem;
            }
            
            .prompt-panel {
                padding: 30px 20px;
                min-height: 180px;
            }
            
            .prompt-text {
                font-size: 1.6rem;
            }
            
            .activity-feed {
                padding: 25px 20px;
            }
            
            .feed-item {
                padding: 15px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .metric-value {
                font-size: 2rem;
            }
            
            .sentiment-score {
                font-size: 2rem;
            }
            
            .prompt-text {
                font-size: 1.4rem;
            }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Add smooth scrolling */
        html {
            scroll-behavior: smooth;
        }

        /* Add custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.6);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.8);
        }

        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 30px 35px;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.15) 0%, rgba(255, 193, 7, 0.1) 100%);
            backdrop-filter: blur(25px);
            border-radius: 30px;
            border: 2px solid rgba(255, 107, 107, 0.3);
            box-shadow: 
                0 15px 35px rgba(255, 107, 107, 0.2),
                0 5px 15px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .dashboard-header:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 20px 40px rgba(255, 107, 107, 0.25),
                0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .dashboard-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #ff6b6b, #ffc107, #ff6b6b);
            animation: headerGlow 3s ease-in-out infinite;
        }

        @keyframes headerGlow {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .dashboard-header h1 {
            margin: 0;
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(135deg, #ffd700 0%, #ff6b6b 50%, #4ecdc4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -1px;
            text-shadow: none;
            position: relative;
            z-index: 2;
            display: flex;
            align-items: center;
        }

        .dashboard-header h1::before {
            content: '🎯';
            display: inline-block;
            margin-right: 15px;
            font-size: 2.5rem;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            animation: iconBounce 2s ease-in-out infinite;
            -webkit-text-fill-color: initial;
            background: none;
            -webkit-background-clip: initial;
            background-clip: initial;
            color: #ffd700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255, 255, 255, 0.1);
            padding: 12px 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .status-text {
            font-weight: 600;
            color: #ffffff;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
        }

        .refresh-btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: white;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .refresh-btn:hover {
            transform: rotate(180deg) scale(1.1);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.5);
        }

        @keyframes iconBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .username-section {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .username-input-container {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
        }

        .username-input-container input {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            width: 300px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .username-input-container button {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        #connectBtn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        #disconnectBtn {
            background: linear-gradient(135deg, #f44336 0%, #da190b 100%);
            color: white;
        }

        .username-input-container button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .current-stream-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }
        
        .stream-status-container {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            color: white;
        }
        

        
        .connection-details {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 0.8rem;
            color: #6c757d;
            padding: 5px 10px;
            background: rgba(108, 117, 125, 0.1);
            border-radius: 15px;
        }
        
        .connection-time {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .connection-duration {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #streamStatus {
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 15px;
            margin-right: 10px;
        }

        #streamerName {
            font-weight: bold;
        }

        /* Clean, simple connection status */
        .connection-status {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 12px 20px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .status-text {
            color: #fff;
            font-weight: 500;
            font-size: 0.9rem;
        }

        /* NEW: Enhanced animations */
        /* connectingPulse animation removed */

        /* connectedGlow animation removed */



        /* Hover effect */
        .connection-status:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        /* Old pulse animation removed - replaced with new animations above */

        .refresh-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
        }

        .refresh-btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0.2) 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .refresh-btn:active {
            transform: translateY(0);
        }
        
        /* Gift Queue Status Styles */
        .gift-queue-status {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.4);
            border-radius: 20px;
            padding: 8px 12px;
            margin-left: 15px;
            animation: pulse 2s infinite;
        }
        
        .queue-icon {
            font-size: 16px;
        }
        
        .queue-count {
            background: #ffc107;
            color: #000;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        
        .queue-clear-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }
        
        .queue-clear-btn:hover {
            background: #c82333;
            transform: scale(1.2);
        }

        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .dashboard-header {
                flex-direction: column;
                gap: 20px;
                text-align: center;
                padding: 20px;
            }
            
            .dashboard-header h1 {
                font-size: 2.2rem;
            }
            
            .connection-status {
                min-width: 200px;
                max-width: 280px;
                padding: 10px 16px;
                justify-content: center;
                gap: 10px;
            }
            
            .status-text {
                font-size: 0.85rem;
            }
            
            .gift-queue-status {
                margin-left: 10px;
                padding: 6px 10px;
            }
            
            .queue-icon {
                font-size: 14px;
            }
            
            .queue-count {
                width: 18px;
                height: 18px;
                font-size: 11px;
            }
            
            .queue-clear-btn {
                width: 18px;
                height: 18px;
                font-size: 9px;
            }
        }

        /* Extra small screens */
        @media (max-width: 480px) {
            .connection-status {
                min-width: 240px;
                max-width: 280px;
                padding: 14px 18px;
                gap: 12px;
            }
            
            .status-text {
                font-size: 0.85rem;
            }
            
            .container {
                padding: 10px;
                margin: 5px;
            }
            
            .dashboard-header h1 {
                font-size: 1.8rem;
            }
            
            .username-input-container input {
                font-size: 1rem;
                padding: 12px;
            }
            
            .username-input-container button {
                font-size: 0.9rem;
                padding: 10px;
            }
            
            .question-stats-bar {
                grid-template-columns: 1fr;
                gap: 10px;
                padding: 10px;
            }
            
            .question-card {
                padding: 15px;
            }
            
            .card-actions {
                gap: 8px;
            }
            
            .action-btn-large {
                padding: 12px;
                font-size: 0.9rem;
            }
            
            .feed-header {
                font-size: 1.1rem;
                padding: 12px;
            }
            
            .feed-item {
                padding: 12px;
                margin-bottom: 8px;
            }
        }

        /* Modern glassmorphism effect */
        .dashboard-header {
            animation: fadeInUp 0.6s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Hover effects for interactive elements */
        .connection-status:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .prompt-history .feed-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 3px solid #007bff;
        }
        
        /* Pending Questions Section - Mobile Optimized */
        .question-highlight {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 25px;
            margin: 30px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
        }
        
        .question-stats-bar {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Responsive question stats bar */
        @media (max-width: 768px) {
            .question-stats-bar {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
                padding: 15px;
            }
        }
        
        @media (max-width: 480px) {
            .question-stats-bar {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
                padding: 12px;
            }
            
            .stat-item {
                padding: 10px;
            }
            
            .stat-label {
                font-size: 0.8rem;
            }
            
            .stat-value {
                font-size: 1.3rem;
            }
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffd700;
        }
        
        .question-slideshow {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .question-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .question-priority-badge {
            background: rgba(255, 165, 0, 0.3);
            color: #ffa500;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            border: 1px solid rgba(255, 165, 0, 0.5);
        }
        
        .question-timer {
            background: rgba(255, 71, 87, 0.3);
            color: #ff4757;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            border: 1px solid rgba(255, 71, 87, 0.5);
        }
        
        .question-content {
            margin-bottom: 25px;
        }
        
        .viewer-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .viewer-icon {
            font-size: 1.2rem;
        }
        
        .viewer-name {
            font-weight: bold;
            color: #00ff88;
        }
        
        .question-text {
            font-size: 1.1rem;
            line-height: 1.5;
            color: #fff;
        }
        
        .card-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .action-btn-large {
            flex: 1;
            padding: 15px 25px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .answer-btn {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #000;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }
        
        .answer-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
        }
        
        .ignore-btn {
            background: linear-gradient(135deg, #ff4757, #ff3742);
            color: #fff;
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3);
        }
        
        .ignore-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 71, 87, 0.4);
        }
        
        .auto-advance-indicator {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .indicator-text {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 8px;
        }
        
        .question-counter {
            font-size: 1.1rem;
            font-weight: bold;
            color: #ffd700;
        }
        
        /* Feed Items and Activity Sections */
        .feed-header {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 20px;
            border-radius: 15px 15px 0 0;
            font-size: 1.3rem;
            font-weight: bold;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .feed-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .feed-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        
        .feed-content {
            color: #fff;
            line-height: 1.5;
        }
        
        .feed-timestamp {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            margin-top: 8px;
            font-style: italic;
        }
        
        /* AI Insights Section */
        .ai-insights {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 25px;
            margin: 30px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
        }
        
        /* Actionable Prompt Section */
        .actionable-prompt {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 25px;
            margin: 30px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
        }
        
        .prompt-content {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .prompt-icon {
            font-size: 2rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .prompt-text {
            flex: 1;
            color: #fff;
            font-size: 1.1rem;
            line-height: 1.5;
        }
        
        .prompt-trigger {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            font-style: italic;
        }
        
        /* TTS Controls Styles */
        .tts-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-left: auto;
        }
        
        .tts-toggle-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tts-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .tts-toggle-btn.active {
            background: rgba(76, 175, 80, 0.3);
            border-color: rgba(76, 175, 80, 0.5);
            color: #4caf50;
        }
        
        .tts-settings {
            display: flex;
            align-items: center;
            gap: 15px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            flex-wrap: wrap;
        }
        
        .tts-settings.visible {
            opacity: 1;
            pointer-events: all;
        }
        
        .tts-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            min-width: 120px;
        }
        
        .tts-select option {
            background: #2c2c2c;
            color: white;
        }
        
        .tts-control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            min-width: 100px;
        }
        
        .tts-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .tts-slider {
            width: 80px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .tts-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4caf50;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .tts-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #4caf50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .tts-value {
            color: #4caf50;
            font-size: 10px;
            font-weight: 600;
            font-family: monospace;
        }
        
        /* Mobile Responsive TTS Controls */
        @media (max-width: 768px) {
            .tts-controls {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
                margin-left: 0;
                margin-top: 15px;
            }
            
            .tts-settings {
                flex-direction: column;
                align-items: stretch;
                gap: 20px;
            }
            
            .tts-control-group {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                min-width: auto;
                gap: 15px;
            }
            
            .tts-select {
                min-width: auto;
                flex: 1;
            }
            
            .tts-slider {
                width: 120px;
                flex: 1;
            }
            
            .tts-label {
                min-width: 60px;
                text-align: left;
            }
            
            .tts-value {
                min-width: 40px;
                text-align: right;
            }
        }
        
        @media (max-width: 480px) {
            .tts-controls {
                margin-top: 20px;
            }
            
            .tts-settings {
                gap: 25px;
            }
            
            .tts-control-group {
                gap: 20px;
            }
            
            .tts-slider {
                width: 100px;
            }
        }
        
        .alert-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        
        .alert-tts-btn {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.4);
            color: #4caf50;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .alert-tts-btn:hover {
            background: rgba(76, 175, 80, 0.3);
            transform: translateY(-2px);
        }
        
        .tts-speaking-indicator {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.4);
            color: #4caf50;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            animation: pulse 2s infinite;
        }
        
        .tts-speaking-indicator.hidden {
            display: none;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* Activity Pagination Styles */
        .activity-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .pagination-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            min-width: 40px;
        }
        
        .pagination-btn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination-current {
            background: rgba(255, 215, 0, 0.3);
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #ffd700;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }
        
        .prompt-history-message {
            font-weight: 500;
            margin-bottom: 4px;
            color: #e9ecef;
        }
        
        .prompt-history-trigger {
            font-size: 0.85em;
            color: #adb5bd;
            font-style: italic;
        }
        
        .actionable-prompt.high-priority {
            border-color: #dc3545;
            box-shadow: 0 0 20px rgba(220, 53, 69, 0.3);
        }
        
        .actionable-prompt.medium-priority {
            border-color: #ffc107;
            box-shadow: 0 0 20px rgba(255, 193, 7, 0.3);
        }
        
        .actionable-prompt.low-priority {
            border-color: #28a745;
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.3);
        }

        /* Non-blocking Gift Notification Styles */
        .gift-notifications-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 350px;
            pointer-events: none;
        }

        .gift-notification {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95) 0%, rgba(255, 165, 0, 0.95) 100%);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            padding: 15px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            animation: slideInRight 0.3s ease-out;
            pointer-events: auto;
            max-height: 200px;
            overflow: hidden;
        }

        .gift-notification.slide-out {
            animation: slideOutRight 0.3s ease-in forwards;
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        .gift-notification-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .gift-notification-icon {
            font-size: 1.5rem;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-5px); }
            60% { transform: translateY(-3px); }
        }

        .gift-notification-title {
            font-weight: bold;
            color: #8B4513;
            font-size: 0.9rem;
        }

        .gift-notification-sender {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .gift-sender-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .gift-sender-name {
            font-weight: 600;
            color: #8B4513;
            font-size: 0.9rem;
        }

        .gift-notification-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .gift-name {
            font-weight: 600;
            color: #8B4513;
            font-size: 0.85rem;
        }

        .gift-value {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            color: #8B4513;
            font-weight: 600;
        }

        .gift-notification-actions {
            display: flex;
            gap: 5px;
            justify-content: flex-end;
        }

        .gift-action-mini {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: #8B4513;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .gift-action-mini:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        /* Compact Gift Queue Indicator Styles */
        .gift-queue-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 999;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            padding: 8px 12px;
        }

        .gift-indicator-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .gift-indicator-icon {
            font-size: 1.2rem;
        }

        .gift-indicator-count {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: bold;
            min-width: 18px;
            text-align: center;
        }

        .gift-indicator-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 4px 6px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            min-width: 28px;
            text-align: center;
        }

        .gift-indicator-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        /* Viewer Notification Styles */
        .viewer-notifications-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 998;
            max-width: 300px;
            max-height: 60vh;
            overflow-y: auto;
            pointer-events: none;
        }
        
        .viewer-notification {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
            animation: slideInRight 0.4s ease-out;
            pointer-events: auto;
            backdrop-filter: blur(20px);
        }
        
        .viewer-notification-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .viewer-notification-icon {
            font-size: 1.2rem;
            animation: bounce 1.5s infinite;
        }
        
        .viewer-notification-title {
            font-size: 0.9rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .viewer-notification-sender {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .viewer-sender-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            object-fit: cover;
        }
        
        .viewer-sender-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .viewer-notification-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        
        .viewer-action-mini {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }
        
        .viewer-action-mini:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }
        
        /* Viewer Counter Indicator Styles */
        .viewer-counter-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 999;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            padding: 8px 12px;
        }
        
        .viewer-indicator-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .viewer-indicator-icon {
            font-size: 1.2rem;
        }
        
        .viewer-indicator-count {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: bold;
            min-width: 18px;
            text-align: center;
        }
        
        .viewer-indicator-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 4px 6px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            min-width: 28px;
            text-align: center;
        }
        
        .viewer-indicator-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }
        
        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            .gift-notifications-container {
                top: 70px;
                right: 10px;
                max-width: 280px;
            }
            
            .viewer-notifications-container {
                top: 70px;
                right: 10px;
                max-width: 280px;
            }
            
            .gift-queue-indicator {
                bottom: 15px;
                right: 15px;
                padding: 6px 10px;
            }
            
            .viewer-counter-indicator {
                bottom: 15px;
                left: 15px;
                padding: 6px 10px;
            }
            
            .gift-indicator-content {
                gap: 6px;
            }
            
            .viewer-indicator-content {
                gap: 6px;
            }
            
            .gift-indicator-icon {
                font-size: 1rem;
            }
            
            .viewer-indicator-icon {
                font-size: 1rem;
            }
            
            .gift-indicator-count {
                padding: 1px 4px;
                font-size: 0.65rem;
                min-width: 16px;
            }
            
            .viewer-indicator-count {
                padding: 1px 4px;
                font-size: 0.65rem;
                min-width: 16px;
            }
            
            .gift-indicator-btn {
                padding: 3px 5px;
                min-width: 24px;
                font-size: 0.75rem;
            }
            
            .viewer-indicator-btn {
                padding: 3px 5px;
                min-width: 24px;
                font-size: 0.75rem;
            }
            
            .gift-notification {
                padding: 12px;
                font-size: 0.85rem;
            }
            
            .viewer-notification {
                padding: 12px;
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-header">
        <div class="header-top-row">
            <h1> TikTok Live Assistant </h1>
            <div class="language-switcher">
                <button class="language-btn active" onclick="switchLanguage('en')">🇺🇸 EN</button>
                <button class="language-btn" onclick="switchLanguage('fr')">🇫🇷 FR</button>
            </div>
        </div>
        <div class="connection-status" id="connectionStatus">
            <span class="status-text" id="statusText">Connecting...</span>
            <button class="refresh-btn" onclick="manualReconnect()" id="refreshBtn" style="display: none;">🔄</button>

        </div>
    </div>

    <div class="container">

        <!-- Username Input Section -->
        <div class="username-section">
            <div class="username-input-container">
                <input type="text" id="usernameInput" placeholder="Enter TikTok username (without @)" value="">
                <button id="connectBtn" onclick="connectToStream()">🔗 Connect</button>
                <button id="disconnectBtn" onclick="disconnectFromStream()" style="display: none;">❌ Disconnect</button>
            </div>
            <div class="current-stream-info" id="currentStreamInfo">
                <div class="stream-status-container">
                    <span id="streamStatus">Not connected</span>
                    <span id="streamerName"></span>
                </div>
                <div class="connection-details" id="connectionDetails" style="display: none;">
                    <span class="connection-time" id="connectionTime"></span>
                    <span class="connection-duration" id="connectionDuration"></span>
                </div>
            </div>
        </div>

        <!-- Entertainment Gauge at the top -->
        <!-- Performance Monitor (Admin Only) -->
        <div class="performance-monitor" id="performanceMonitor" style="display: none;">
            <h3>🖥️ System Performance</h3>
            <div class="performance-grid">
                <div class="perf-card">
                    <span class="perf-label">Memory Usage:</span>
                    <span class="perf-value" id="memoryUsage">--</span>
                </div>
                <div class="perf-card">
                    <span class="perf-label">Uptime:</span>
                    <span class="perf-value" id="uptime">--</span>
                </div>
                <div class="perf-card">
                    <span class="perf-label">Active Viewers:</span>
                    <span class="perf-value" id="activeViewers">--</span>
                </div>
                <div class="perf-card">
                    <span class="perf-label">Connection Mode:</span>
                    <span class="perf-value" id="connectionMode">--</span>
                </div>
            </div>
            <button class="perf-refresh-btn" onclick="refreshPerformance()">🔄 Refresh</button>
        </div>
        
        <div class="entertainment-gauge">
            <h3>Live Chat Score</h3>
            
            <!-- Main Entertainment Score -->
            <div class="entertainment-main">
                <div class="score-display">
                    <div class="score-number" id="entertainmentScore">0</div>
                    <div class="score-label" id="entertainmentLabel">Neutral</div>
                </div>
                
                <!-- Progress Bar -->
                <div class="progress-container">
                    <div class="progress-markers">
                        <div class="marker boring">😴</div>
                        <div class="marker meh">😐</div>
                        <div class="marker good">😊</div>
                        <div class="marker entertaining">🎉</div>
                        <div class="marker fire">🔥</div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-labels">
                        <span>Boring</span>
                        <span>Meh</span>
                        <span>Good</span>
                        <span>Entertaining</span>
                        <span>Fire!</span>
                    </div>
                </div>
            </div>
            
            <!-- Entertainment Breakdown -->
            <div class="entertainment-breakdown">
                <div class="breakdown-item">
                    <div class="breakdown-icon">📊</div>
                    <div class="breakdown-label">Engagement</div>
                    <div class="breakdown-value" id="engagementIntensity">0%</div>
                </div>
                <div class="breakdown-item">
                    <div class="breakdown-icon">🎭</div>
                    <div class="breakdown-label">Content</div>
                    <div class="breakdown-value" id="contentReception">0%</div>
                </div>
                <div class="breakdown-item">
                    <div class="breakdown-icon">⚡</div>
                    <div class="breakdown-label">Energy</div>
                    <div class="breakdown-value" id="audienceEnergy">0%</div>
                </div>
                <div class="breakdown-item">
                    <div class="breakdown-icon">📈</div>
                    <div class="breakdown-label">Retention</div>
                    <div class="breakdown-value" id="retentionQuality">0%</div>
                </div>
            </div>
        </div>
        


        <!-- Actionable Prompt Section -->
        <div class="actionable-prompt">
            <div class="feed-header">
                🎯 LIVE ASSISTANT
                <div class="tts-controls">
                    <button id="ttsToggle" class="tts-toggle-btn" title="Toggle Text-to-Speech (Ctrl+Shift+T)">
                        🔊 <span id="ttsStatus">OFF</span>
                    </button>
                    <div class="tts-settings" id="ttsSettings">
                        <select id="ttsVoice" class="tts-select" title="Select Voice">
                            <option value="">Loading voices...</option>
                        </select>
                        <div class="tts-control-group">
                            <label for="ttsSpeed" class="tts-label">Speed</label>
                            <input type="range" id="ttsSpeed" min="0.5" max="2" step="0.1" value="1" class="tts-slider" title="Speech Speed">
                            <span class="tts-value" id="ttsSpeedValue">1.0x</span>
                        </div>
                        <div class="tts-control-group">
                            <label for="ttsVolume" class="tts-label">Volume</label>
                            <input type="range" id="ttsVolume" min="0" max="1" step="0.1" value="0.8" class="tts-slider" title="Volume">
                            <span class="tts-value" id="ttsVolumeValue">80%</span>
                        </div>
                    </div>
                </div>
            </div>
            <div id="actionablePrompt">
                <div class="prompt-content">
                    <div class="prompt-icon">🤖</div>
                    <div class="prompt-text">Waiting for AI insights...</div>
                    <div class="prompt-trigger">No triggers detected yet</div>
                    <div id="ttsSpeakingIndicator" class="tts-speaking-indicator hidden">
                        🔊 Speaking...
                    </div>
                </div>
            </div>
        </div>

        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-value" id="viewerCount">0</div>
                <div class="metric-label">Live Viewers</div>
                <div class="metric-trend" id="viewerTrend"></div>
            </div>

            <div class="metric-card">
                <div class="metric-value" id="followersGains">0</div>
                <div class="metric-label">New Followers</div>
                <div class="metric-subtitle" id="followersGainsSubtitle">0 gained this stream</div>
                <div class="metric-trend" id="followersGainsTrend"></div>
            </div>

            <div class="metric-card">
                <div class="metric-value" id="totalLikes">0</div>
                <div class="metric-label">Total Likes</div>
                <div class="metric-trend" id="totalLikesTrend"></div>
            </div>

            <div class="metric-card">
                <div class="metric-value" id="totalGifts">0</div>
                <div class="metric-label">Total Gifts</div>
                <div class="metric-subtitle" id="totalGiftsValue">$0.00 total value</div>
                <div class="metric-trend" id="totalGiftsTrend"></div>
            </div>

            <div class="metric-card">
                <div class="metric-value" id="likesPerMinute">0</div>
                <div class="metric-label">Likes per Minute</div>
                <div class="metric-trend" id="likesPerMinuteTrend"></div>
            </div>

            <div class="metric-card">
                <div class="metric-value" id="totalShares">0</div>
                <div class="metric-label">Total Shares</div>
                <div class="metric-trend" id="totalSharesTrend"></div>
            </div>
        </div>

        <!-- Viewer Watch Time Statistics -->
            <!-- Non-blocking Gift Notifications -->
            <div id="giftNotificationsContainer" class="gift-notifications-container">
                <!-- Gift notifications will be dynamically added here -->
            </div>
            
            <!-- Non-blocking Viewer Notifications -->
            <div id="viewerNotificationsContainer" class="viewer-notifications-container">
                <!-- Viewer notifications will be dynamically added here -->
            </div>
            
            <!-- Compact Gift Queue Indicator -->
            <div id="giftQueueIndicator" class="gift-queue-indicator">
                <div class="gift-indicator-content">
                    <span class="gift-indicator-icon">🎁</span>
                    <span class="gift-indicator-count" id="giftIndicatorCount">0</span>
                    <button class="gift-indicator-btn" onclick="clearGiftQueue()" title="Clear all gifts">🚨</button>
                    <button class="gift-indicator-btn" onclick="pauseGiftNotifications()" id="pauseGiftBtn" title="Pause">⏸️</button>
                    <button class="gift-indicator-btn" onclick="resumeGiftNotifications()" id="resumeGiftBtn" title="Resume" style="display: none;">▶️</button>
                </div>
            </div>
            
            <!-- Compact Viewer Counter Indicator -->
            <div id="viewerCounterIndicator" class="viewer-counter-indicator">
                <div class="viewer-indicator-content">
                    <span class="viewer-indicator-icon">👋</span>
                    <span class="viewer-indicator-count" id="viewerIndicatorCount">0</span>
                    <button class="viewer-indicator-btn" onclick="clearViewerHistory()" title="Clear viewer history">🗑️</button>
                    <button class="viewer-indicator-btn" onclick="pauseViewerNotifications()" id="pauseViewerBtn" title="Pause">⏸️</button>
                    <button class="viewer-indicator-btn" onclick="resumeViewerNotifications()" id="resumeViewerBtn" title="Resume" style="display: none;">▶️</button>
                </div>
            </div>

        <div class="question-highlight">
            <div class="feed-header"> Viewers Questions ❓</div>
            
            <!-- Question Stats Bar -->
            <div class="question-stats-bar">
                <div class="stat-item">
                    <div class="stat-label">Total</div>
                    <div class="stat-value" id="totalQuestions">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Response Rate</div>
                    <div class="stat-value" id="responseRate">0%</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Avg Time</div>
                    <div class="stat-value" id="avgResponseTime">0s</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Priority</div>
                    <div class="stat-value" id="currentPriority">-</div>
                </div>
            </div>
            
            <!-- Question Slideshow Card -->
            <div class="question-slideshow" id="questionSlideshow">
                <div class="slideshow-container">
                    <div class="question-card" id="currentQuestionCard">
                        <div class="card-header">
                            <div class="question-priority-badge" id="priorityBadge">-</div>
                            <div class="question-timer" id="questionTimer">-</div>
                        </div>
                        
                        <div class="question-content">
                            <div class="viewer-info">
                                <span class="viewer-icon">👤</span>
                                <span class="viewer-name" id="viewerName">-</span>
                            </div>
                            <div class="question-text" id="questionText">No pending questions...</div>
                        </div>
                        
                        <div class="card-actions">
                            <button class="action-btn-large answer-btn" id="answerBtn" onclick="handleQuestionAnswered()">
                                <span class="btn-icon">✅</span>
                                <span class="btn-text">ANSWERED</span>
                            </button>
                            <button class="action-btn-large ignore-btn" id="ignoreBtn" onclick="handleQuestionIgnored()">
                                <span class="btn-icon">❌</span>
                                <span class="btn-text">IGNORE</span>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Auto-advance indicator -->
                <div class="auto-advance-indicator">
                    <div class="indicator-text" id="autoAdvanceStatus">Auto-advancing questions...</div>
                    <div class="question-counter" id="questionCounter">0 / 0</div>
                </div>
            </div>
        </div>

        <div class="viewer-stats-section">
            <h2>👥 Viewer Watch Time Analytics</h2>
            <div class="viewer-stats-grid">
                <div class="viewer-stat-card">
                    <div class="stat-value" id="totalUniqueViewers">0</div>
                    <div class="stat-label">Total Joined Viewers</div>
                </div>
                <div class="viewer-stat-card">
                    <div class="stat-value" id="averageWatchTime">0s</div>
                    <div class="stat-label">Average Watch Time</div>
                </div>
                <div class="viewer-stat-card">
                    <div class="stat-value" id="longestWatchTime">0s</div>
                    <div class="stat-label">Longest Watch Time</div>
                </div>
                <div class="viewer-stat-card">
                    <div class="stat-value" id="viewerRetentionRate">0%</div>
                    <div class="stat-label">Viewer Retention</div>
                    <div class="stat-subtitle">Current / Total Unique</div>
                </div>
            </div>
        </div>

        <div class="ai-insights">
            <div class="feed-header">Live Stream Insights & Trends</div>
            <div id="aiInsights">
                <div class="feed-item">
                    <div class="feed-content">Waiting for AI analysis...</div>
                </div>
            </div>
        </div>



        <div class="predictive-analytics">
            <div class="feed-header">🔮 Predictive Analytics</div>
            <div class="predictive-grid">
                <div class="predictive-card churn-risk">
                    <div class="predictive-icon">🚨</div>
                    <div class="predictive-title">Churn Risk</div>
                    <div class="predictive-value" id="churnRiskScore">0%</div>
                    <div class="predictive-trend" id="churnRiskTrend">Stable</div>
                </div>
                
                <div class="predictive-card monetization">
                    <div class="predictive-icon">💰</div>
                    <div class="predictive-title">Monetization Opportunity</div>
                    <div class="predictive-value" id="monetizationScore">0%</div>
                    <div class="predictive-trend" id="monetizationTrend">Low</div>
                </div>
                
                <div class="predictive-card retention">
                    <div class="predictive-icon">📈</div>
                    <div class="predictive-title">Viewer Retention</div>
                    <div class="predictive-value" id="retentionRate">0%</div>
                    <div class="predictive-trend" id="retentionTrend">Stable</div>
                </div>
                
                <div class="predictive-card volatility">
                    <div class="predictive-icon">📊</div>
                    <div class="predictive-title">Sentiment Volatility</div>
                    <div class="predictive-value" id="sentimentVolatility">0</div>
                    <div class="predictive-trend" id="volatilityTrend">Low</div>
                </div>
            </div>
            
            <div class="predictive-insights" id="predictiveInsights">
                <div class="feed-item">
                    <div class="feed-content">Waiting for predictive analysis...</div>
                </div>
            </div>
        </div>

        <div class="activity-feed">
            <div class="feed-header">📊 Chat Activity</div>
            
            <!-- Activity Tabs -->
            <div class="activity-tabs">
                <button class="tab-btn active" onclick="switchActivityTab('all')">All</button>
                <button class="tab-btn" onclick="switchActivityTab('messages')">💬 Messages</button>
                <button class="tab-btn" onclick="switchActivityTab('engagements')">❤️ Engagements</button>
            </div>
            
            <!-- Activity Summary Bar -->
            <div class="activity-summary">
                <div class="summary-item">
                    <span class="summary-icon">💬</span>
                    <span class="summary-count" id="commentCount">0</span>
                </div>
                <div class="summary-item">
                    <span class="summary-icon">❤️</span>
                    <span class="summary-count" id="likeCount">0</span>
                </div>
                <div class="summary-item">
                    <span class="summary-icon">🎁</span>
                    <span class="summary-count" id="giftCount">0</span>
                </div>
                <div class="summary-item">
                    <span class="summary-icon">👥</span>
                    <span class="summary-count" id="viewerCount">0</span>
                </div>
            </div>
            
            <!-- Smart Activity Display -->
            <div id="activityFeed">
                <div class="feed-item">
                    <div class="feed-content">Dashboard loaded and ready for live data...</div>
                </div>
            </div>
            
            <!-- Activity Pagination -->
            <div id="activityPagination" class="activity-pagination"></div>
            
            <!-- Activity Controls -->
            <div class="activity-controls">
                <div class="control-group">
                    <label class="control-label">Items per Page:</label>
                    <select id="maxItems" onchange="updateMaxItems()">
                        <option value="10">10</option>
                        <option value="20" selected>20</option>
                        <option value="30">30</option>
                        <option value="50">50</option>
                    </select>
                </div>
                <div class="control-group">
                    <button class="control-btn" onclick="togglePerformanceMode()" id="perfToggleBtn" title="Toggle between full feed and lightweight mode">
                        🚀 Performance Mode
                    </button>
                </div>
                <button class="control-btn" onclick="toggleActivityPause()" id="pauseBtn">
                    ⏸️ Pause
                </button>
            </div>
        </div>
        
        <div class="top-engagers">
            <div class="feed-header">🏆 Top Engaged Users</div>
            <div id="topEngagedUsers">
                <div class="feed-item">
                    <div class="feed-content">Waiting for engagement data...</div>
                </div>
            </div>
        </div>
        
        <div class="new-followers">
            <div class="feed-header">🆕 New Followers</div>
            <div id="newFollowers">
                <div class="feed-item">
                    <div class="feed-content">No new followers yet...</div>
                </div>
            </div>
        </div>
        
        <div class="prompt-history">
            <div class="feed-header">📜 Prompt History</div>
            <div id="promptHistory">
                <div class="feed-item">
                    <div class="feed-content">No prompts generated yet...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Language and Translations
        const translations = {
            en: {
                // Dashboard Header
                dashboardTitle: "TikTok Live Assistant",
                connectionStatus: "Connection Status",
                connecting: "Connecting...",
                connected: "Connected",
                disconnected: "Disconnected",
                failed: "Connection Failed",
                error: "Connection Error",
                
                // Username Section
                usernamePlaceholder: "Enter TikTok username (without @)",
                connectBtn: "🔗 Connect",
                disconnectBtn: "❌ Disconnect",
                notConnected: "Not connected",
                reconnecting: "Reconnecting...",
                
                // Entertainment Gauge
                liveMoodScore: "Live Chat Score",
                neutral: "Neutral",
                boring: "Boring",
                meh: "Meh",
                good: "Good",
                entertaining: "Entertaining",
                fire: "Fire!",
                engagement: "Engagement",
                
                // Metrics
                liveViewers: "Live Viewers",
                newFollowers: "New Followers",
                totalLikes: "Total Likes",
                totalGifts: "Total Gifts",
                likesPerMinute: "Likes per Minute",
                totalShares: "Total Shares",
                followersGained: "gained this stream",
                totalValue: "total value",
                
                // Performance Monitor
                systemPerformance: "🖥️ System Performance",
                memoryUsage: "Memory Usage:",
                uptime: "Uptime:",
                activeViewers: "Active Viewers:",
                connectionMode: "Connection Mode:",
                refresh: "🔄 Refresh",
                
                // Activity Feed
                liveActivity: "Live Activity",
                waitingForConnection: "Waiting for connection to stream...",
                now: "Now",
                
                // Additional Elements
                streamStatus: "Not connected",
                streamerName: "",
                connectionTime: "",
                connectionDuration: "",
                giftQueueStatus: "Gift Queue",
                queueIcon: "🎁",
                queueCount: "0",
                clearGifts: "🚨",
                clearGiftsTitle: "Clear all pending gifts",
                manualReconnect: "🔄",
                manualReconnectTitle: "Manual Reconnect",
                
                // Entertainment Breakdown
                content: "Content",
                energy: "Energy",
                retention: "Retention",
                
                // AI Insights
                waitingForAIInsights: "Waiting for AI insights...",
                noTriggersDetected: "No triggers detected yet",
                
                // Questions Section
                viewersQuestions: "Viewers Questions ❓",
                total: "Total",
                responseRate: "Response Rate",
                avgTime: "Avg Time",
                priority: "Priority",
                noPendingQuestions: "No pending questions...",
                answered: "ANSWERED",
                ignore: "IGNORE",
                
                // Viewer Analytics
                viewerWatchTimeAnalytics: "👥 Viewer Watch Time Analytics",
                totalJoinedViewers: "Total Joined Viewers",
                averageWatchTime: "Average Watch Time",
                longestWatchTime: "Longest Watch Time",
                viewerRetention: "Viewer Retention",
                currentTotalUnique: "Current / Total Unique",
                liveStreamInsightsTrends: "Live Stream Insights & Trends",
                waitingForAIAnalysis: "Waiting for AI analysis...",
                
                // Predictive Analytics
                predictiveAnalytics: "🔮 Predictive Analytics",
                churnRisk: "Churn Risk",
                stable: "Stable",
                monetizationOpportunity: "Monetization Opportunity",
                low: "Low",
                sentimentVolatility: "Sentiment Volatility",
                waitingForPredictiveAnalysis: "Waiting for predictive analysis...",
                
                // Chat Activity
                chatActivity: "📊 Chat Activity",
                all: "All",
                messages: "💬 Messages",
                engagements: "❤️ Engagements",
                itemsPerPage: "Items per Page:",
                
                // Performance & Users
                performanceMode: "🚀 Performance Mode",
                pause: "⏸️ Pause",
                topEngagedUsers: "🏆 Top Engaged Users",
                waitingForEngagementData: "Waiting for engagement data...",
                newFollowers: "🆕 New Followers",
                noNewFollowersYet: "No new followers yet...",
                promptHistory: "📜 Prompt History",
                noPromptsGeneratedYet: "No prompts generated yet..."
            },
            fr: {
                // Dashboard Header
                dashboardTitle: "Assistant TikTok Live",
                connectionStatus: "Statut de la Connexion",
                connecting: "Connexion...",
                connected: "Connecté",
                disconnected: "Déconnecté",
                failed: "Échec de Connexion",
                error: "Erreur de Connexion",
                
                // Username Section
                usernamePlaceholder: "Nom d'utilisateur TikTok (sans @)",
                connectBtn: "🔗 Se Connecter",
                disconnectBtn: "❌ Se Déconnecter",
                notConnected: "Non Connecté",
                reconnecting: "Reconnexion...",
                
                // Entertainment Gauge
                liveMoodScore: "Live Chat Score",
                neutral: "Neutre",
                boring: "Ennuyeux",
                meh: "Bof",
                good: "Bien",
                entertaining: "Divertissant",
                fire: "Feu!",
                engagement: "Engagement",
                
                // Metrics
                liveViewers: "Spectateurs en Direct",
                newFollowers: "Nouveaux Abonnés",
                totalLikes: "Total des Likes",
                totalGifts: "Total des Cadeaux",
                likesPerMinute: "Likes par Minute",
                totalShares: "Total des Partages",
                followersGained: "gagnés ce stream",
                totalValue: "valeur totale",
                
                // Performance Monitor
                systemPerformance: "🖥️ Performance du Système",
                memoryUsage: "Utilisation Mémoire:",
                uptime: "Temps de Fonctionnement:",
                activeViewers: "Spectateurs Actifs:",
                connectionMode: "Mode de Connexion:",
                refresh: "🔄 Actualiser",
                
                // Activity Feed
                liveActivity: "Activité en Direct",
                waitingForConnection: "En attente de connexion au stream...",
                now: "Maintenant",
                
                // Additional Elements
                streamStatus: "Non connecté",
                streamerName: "",
                connectionTime: "",
                connectionDuration: "",
                giftQueueStatus: "File d'Attente des Cadeaux",
                queueIcon: "🎁",
                queueCount: "0",
                clearGifts: "🚨",
                clearGiftsTitle: "Effacer tous les cadeaux en attente",
                manualReconnect: "🔄",
                manualReconnectTitle: "Reconnexion Manuelle",
                
                // Entertainment Breakdown
                content: "Contenu",
                energy: "Énergie",
                retention: "Rétention",
                
                // AI Insights
                waitingForAIInsights: "En attente des insights IA...",
                noTriggersDetected: "Aucun déclencheur détecté encore",
                
                // Questions Section
                viewersQuestions: "Questions des Spectateurs ❓",
                total: "Total",
                responseRate: "Taux de Réponse",
                avgTime: "Temps Moyen",
                priority: "Priorité",
                noPendingQuestions: "Aucune question en attente...",
                answered: "RÉPONDU",
                ignore: "IGNORER",
                
                // Viewer Analytics
                viewerWatchTimeAnalytics: "👥 Analyse du Temps de Visionnage",
                totalJoinedViewers: "Total des Spectateurs Rejoints",
                averageWatchTime: "Temps de Visionnage Moyen",
                longestWatchTime: "Temps de Visionnage le Plus Long",
                viewerRetention: "Rétention des Spectateurs",
                currentTotalUnique: "Actuel / Total Unique",
                liveStreamInsightsTrends: "Insights et Tendances du Stream en Direct",
                waitingForAIAnalysis: "En attente de l'analyse IA...",
                
                // Predictive Analytics
                predictiveAnalytics: "🔮 Analyse Prédictive",
                churnRisk: "Risque de Perte",
                stable: "Stable",
                monetizationOpportunity: "Opportunité de Monétisation",
                low: "Faible",
                sentimentVolatility: "Volatilité du Sentiment",
                waitingForPredictiveAnalysis: "En attente de l'analyse prédictive...",
                
                // Chat Activity
                chatActivity: "📊 Activité du Chat",
                all: "Tout",
                messages: "💬 Messages",
                engagements: "❤️ Engagements",
                itemsPerPage: "Éléments par Page:",
                
                // Performance & Users
                performanceMode: "🚀 Mode Performance",
                pause: "⏸️ Pause",
                topEngagedUsers: "🏆 Top des Utilisateurs Engagés",
                waitingForEngagementData: "En attente des données d'engagement...",
                newFollowers: "🆕 Nouveaux Abonnés",
                noNewFollowersYet: "Aucun nouvel abonné encore...",
                promptHistory: "📜 Historique des Prompts",
                noPromptsGeneratedYet: "Aucun prompt généré encore..."
            }
        };

        let currentLanguage = 'en';

        // Language switching functionality
        function switchLanguage(lang) {
            if (lang === currentLanguage) return;
            
            console.log('🔄 Switching language to:', lang);
            currentLanguage = lang;
            
            // Update language buttons
            document.querySelectorAll('.language-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update HTML lang attribute
            document.documentElement.lang = lang;
            
            // Update page content
            updateLanguageContent();
            
            // Save language preference
            localStorage.setItem('dashboard_language', lang);
            console.log('✅ Language switched to:', lang);
        }

        // Update all text content based on current language
        function updateLanguageContent() {
            const t = translations[currentLanguage];
            console.log('🔄 Updating content for language:', currentLanguage);
            
            // Comprehensive text replacement for the entire dashboard
            translateAllTextContent();
            
            // Update specific elements that need special handling
            updateSpecificElements();
        }

        // Comprehensive text translation function
        function translateAllTextContent() {
            const t = translations[currentLanguage];
            const tEn = translations.en;
            const tFr = translations.fr;
            
            console.log('🔄 Starting comprehensive text translation...');
            
            // Get all text nodes in the document
            const walker = document.createTreeWalker(
                document.body,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(node) {
                        // Skip script and style content
                        if (node.parentElement && 
                            (node.parentElement.tagName === 'SCRIPT' || 
                             node.parentElement.tagName === 'STYLE')) {
                            return NodeFilter.FILTER_REJECT;
                        }
                        // Only process nodes with actual text content
                        if (node.textContent.trim().length > 0) {
                            return NodeFilter.FILTER_ACCEPT;
                        }
                        return NodeFilter.FILTER_REJECT;
                    }
                }
            );
            
            let textNode;
            let translationCount = 0;
            
            while (textNode = walker.nextNode()) {
                const originalText = textNode.textContent.trim();
                if (originalText.length === 0) continue;
                
                // Try to find a translation for this text
                const translatedText = findTranslation(originalText, t, tEn, tFr);
                
                if (translatedText && translatedText !== originalText) {
                    textNode.textContent = translatedText;
                    translationCount++;
                    console.log(`🔄 Translated: "${originalText}" → "${translatedText}"`);
                }
            }
            
            console.log(`✅ Comprehensive translation complete. Updated ${translationCount} text elements.`);
        }

        // Find translation for a given text
        function findTranslation(text, t, tEn, tFr) {
            // Direct text matches
            for (const [key, value] of Object.entries(tEn)) {
                if (text === value) {
                    return t[key];
                }
            }
            
            // French text matches (for switching back to English)
            for (const [key, value] of Object.entries(tFr)) {
                if (text === value) {
                    return t[key];
                }
            }
            
            // Partial matches for common patterns
            if (text.includes('Live Chat Score')) return t.liveMoodScore;
            if (text.includes('Live Mood Score')) return t.liveMoodScore;
            if (text.includes('Score d\'Humeur en Direct')) return t.liveMoodScore;
            
            // Return null if no translation found
            return null;
        }

        // Update specific elements that need special handling
        function updateSpecificElements() {
            const t = translations[currentLanguage];
            
            // Update HTML lang attribute
            document.documentElement.lang = currentLanguage;
            
            // Update input placeholders
            const inputs = document.querySelectorAll('input[placeholder]');
            inputs.forEach(input => {
                if (input.placeholder.includes('Enter TikTok username') || 
                    input.placeholder.includes('Nom d\'utilisateur TikTok')) {
                    input.placeholder = t.usernamePlaceholder;
                }
            });
            
            // Update button titles and tooltips
            const buttons = document.querySelectorAll('button[title]');
            buttons.forEach(button => {
                if (button.title.includes('Manual Reconnect') || 
                    button.title.includes('Reconnexion Manuelle')) {
                    button.title = t.manualReconnectTitle;
                }
                if (button.title.includes('Clear all pending gifts') || 
                    button.title.includes('Effacer tous les cadeaux')) {
                    button.title = t.clearGiftsTitle;
                }
            });
        }

        // Update metrics labels and subtitles
        function updateMetricsLabels() {
            const t = translations[currentLanguage];
            const tEn = translations.en;
            const tFr = translations.fr;
            console.log('🔄 Updating metrics labels for language:', currentLanguage);
            
            // Find and update metric cards
            const metricCards = document.querySelectorAll('.metric-card');
            console.log('📊 Found metric cards:', metricCards.length);
            metricCards.forEach((card) => {
                const labelElement = card.querySelector('.metric-label');
                const subtitleElement = card.querySelector('.metric-subtitle');
                
                if (labelElement) {
                    // Update labels based on current text content (check both languages)
                    const currentLabel = labelElement.textContent.trim();
                    
                    // Check for both English and French versions
                    if (currentLabel === 'Live Viewers' || currentLabel === tFr.liveViewers) {
                        labelElement.textContent = t.liveViewers;
                    } else if (currentLabel === 'New Followers' || currentLabel === tFr.newFollowers) {
                        labelElement.textContent = t.newFollowers;
                    } else if (currentLabel === 'Total Likes' || currentLabel === tFr.totalLikes) {
                        labelElement.textContent = t.totalLikes;
                    } else if (currentLabel === 'Total Gifts' || currentLabel === tFr.totalGifts) {
                        labelElement.textContent = t.totalGifts;
                    } else if (currentLabel === 'Likes per Minute' || currentLabel === tFr.likesPerMinute) {
                        labelElement.textContent = t.likesPerMinute;
                    } else if (currentLabel === 'Total Shares' || currentLabel === tFr.totalShares) {
                        labelElement.textContent = t.totalShares;
                    }
                }
                
                if (subtitleElement) {
                    // Update subtitles based on current text content (check both languages)
                    const currentSubtitle = subtitleElement.textContent.trim();
                    
                    if (currentSubtitle.includes('gained this stream') || currentSubtitle.includes('gagnés ce stream')) {
                        subtitleElement.textContent = t.followersGained;
                    } else if (currentSubtitle.includes('total value') || currentSubtitle.includes('valeur totale')) {
                        subtitleElement.textContent = t.totalValue;
                    }
                }
            });
        }

        // Update entertainment breakdown labels


        // Update AI insights section
        function updateAIInsights() {
            const t = translations[currentLanguage];
            const tEn = translations.en;
            const tFr = translations.fr;
            
            // Update AI insights waiting text
            const aiInsightsElements = document.querySelectorAll('*');
            aiInsightsElements.forEach(element => {
                if (element.textContent === 'Waiting for AI insights...' || element.textContent === tFr.waitingForAIInsights) {
                    element.textContent = t.waitingForAIInsights;
                } else if (element.textContent === 'No triggers detected yet' || element.textContent === tFr.noTriggersDetected) {
                    element.textContent = t.noTriggersDetected;
                }
            });
        }

        // Update questions section
        function updateQuestionsSection() {
            const t = translations[currentLanguage];
            const tEn = translations.en;
            const tFr = translations.fr;
            
            // Update questions header
            const questionsHeader = document.querySelector('.feed-header');
            if (questionsHeader && (questionsHeader.textContent.includes('Viewers Questions') || questionsHeader.textContent.includes('Questions des Spectateurs'))) {
                questionsHeader.textContent = t.viewersQuestions;
            }
            
            // Update question stats labels
            const statLabels = document.querySelectorAll('.stat-label');
            statLabels.forEach(label => {
                const currentText = label.textContent.trim();
                if (currentText === 'Total' || currentText === tFr.total) label.textContent = t.total;
                else if (currentText === 'Response Rate' || currentText === tFr.responseRate) label.textContent = t.responseRate;
                else if (currentText === 'Avg Time' || currentText === tFr.avgTime) label.textContent = t.avgTime;
                else if (currentText === 'Priority' || currentText === tFr.priority) label.textContent = t.priority;
            });
            
            // Update question action buttons
            const actionButtons = document.querySelectorAll('.action-btn');
            actionButtons.forEach(btn => {
                if (btn.textContent === '✅ ANSWERED' || btn.textContent === '✅ ' + tFr.answered) btn.textContent = '✅ ' + t.answered;
                else if (btn.textContent === '❌ IGNORE' || btn.textContent === '❌ ' + tFr.ignore) btn.textContent = '❌ ' + t.ignore;
            });
            
            // Update no questions text
            const noQuestionsElements = document.querySelectorAll('*');
            noQuestionsElements.forEach(element => {
                if (element.textContent === 'No pending questions...' || element.textContent === tFr.noPendingQuestions) {
                    element.textContent = t.noPendingQuestions;
                }
            });
        }

        // Update viewer analytics section
        function updateViewerAnalytics() {
            const t = translations[currentLanguage];
            
            // Update viewer analytics header
            const analyticsHeaders = document.querySelectorAll('h3, .feed-header');
            analyticsHeaders.forEach(header => {
                if (header.textContent.includes('Viewer Watch Time Analytics')) {
                    header.textContent = t.viewerWatchTimeAnalytics;
                } else if (header.textContent.includes('Live Stream Insights & Trends')) {
                    header.textContent = t.liveStreamInsightsTrends;
                }
            });
            
            // Update analytics labels
            const analyticsLabels = document.querySelectorAll('*');
            analyticsLabels.forEach(element => {
                if (element.textContent === 'Total Joined Viewers') element.textContent = t.totalJoinedViewers;
                else if (element.textContent === 'Average Watch Time') element.textContent = t.averageWatchTime;
                else if (element.textContent === 'Longest Watch Time') element.textContent = t.longestWatchTime;
                else if (element.textContent === 'Viewer Retention') element.textContent = t.viewerRetention;
                else if (element.textContent === 'Current / Total Unique') element.textContent = t.currentTotalUnique;
                else if (element.textContent === 'Waiting for AI analysis...') element.textContent = t.waitingForAIAnalysis;
            });
        }

        // Update predictive analytics section
        function updatePredictiveAnalytics() {
            const t = translations[currentLanguage];
            
            // Update predictive analytics header
            const predHeaders = document.querySelectorAll('h3, .feed-header');
            predHeaders.forEach(header => {
                if (header.textContent.includes('Predictive Analytics')) {
                    header.textContent = t.predictiveAnalytics;
                }
            });
            
            // Update predictive analytics labels
            const predLabels = document.querySelectorAll('*');
            predLabels.forEach(element => {
                if (element.textContent === 'Churn Risk') element.textContent = t.churnRisk;
                else if (element.textContent === 'Stable') element.textContent = t.stable;
                else if (element.textContent === 'Monetization Opportunity') element.textContent = t.monetizationOpportunity;
                else if (element.textContent === 'Low') element.textContent = t.low;
                else if (element.textContent === 'Sentiment Volatility') element.textContent = t.sentimentVolatility;
                else if (element.textContent === 'Waiting for predictive analysis...') element.textContent = t.waitingForPredictiveAnalysis;
            });
        }

        // Update chat activity section
        function updateChatActivity() {
            const t = translations[currentLanguage];
            
            // Update chat activity header
            const chatHeaders = document.querySelectorAll('h3, .feed-header');
            chatHeaders.forEach(header => {
                if (header.textContent.includes('Chat Activity')) {
                    header.textContent = t.chatActivity;
                }
            });
            
            // Update chat activity labels
            const chatLabels = document.querySelectorAll('*');
            chatLabels.forEach(element => {
                if (element.textContent === 'All') element.textContent = t.all;
                else if (element.textContent === '💬 Messages') element.textContent = t.messages;
                else if (element.textContent === '❤️ Engagements') element.textContent = t.engagements;
                else if (element.textContent === 'Items per Page:') element.textContent = t.itemsPerPage;
            });
        }

        // Update performance and users section
        function updatePerformanceAndUsers() {
            const t = translations[currentLanguage];
            
            // Update performance and users headers
            const perfHeaders = document.querySelectorAll('h3, .feed-header');
            perfHeaders.forEach(header => {
                if (header.textContent.includes('Performance Mode')) header.textContent = t.performanceMode;
                else if (header.textContent.includes('Top Engaged Users')) header.textContent = t.topEngagedUsers;
                else if (header.textContent.includes('New Followers')) header.textContent = t.newFollowers;
                else if (header.textContent.includes('Prompt History')) header.textContent = t.promptHistory;
            });
            
            // Update performance and users labels
            const perfLabels = document.querySelectorAll('*');
            perfLabels.forEach(element => {
                if (element.textContent === '⏸️ Pause') element.textContent = t.pause;
                else if (element.textContent === 'Waiting for engagement data...') element.textContent = t.waitingForEngagementData;
                else if (element.textContent === 'No new followers yet...') element.textContent = t.noNewFollowersYet;
                else if (element.textContent === 'No prompts generated yet...') element.textContent = t.noPromptsGeneratedYet;
            });
        }

        // Load saved language preference on page load
        function loadLanguagePreference() {
            const savedLang = localStorage.getItem('dashboard_language');
            if (savedLang && (savedLang === 'en' || savedLang === 'fr')) {
                currentLanguage = savedLang;
                document.documentElement.lang = savedLang;
                
                // Update language button states
                document.querySelectorAll('.language-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.textContent.includes(savedLang === 'en' ? 'EN' : 'FR')) {
                        btn.classList.add('active');
                    }
                });
                
                // Update content
                updateLanguageContent();
            }
        }

        // WebSocket connection
        let ws = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        const reconnectDelay = 2000; // 2 seconds

        function updateConnectionStatus(status, className) {
            const text = document.getElementById('statusText');
            const refreshBtn = document.getElementById('refreshBtn');
            const connectionStatus = document.getElementById('connectionStatus');
            
            // Update status text
            text.textContent = status;
            
            // Update connection status class for color coding
            connectionStatus.className = `connection-status ${className}`;
            
            // Show refresh button when disconnected or failed
            if (className === 'disconnected' || status.includes('Failed') || status.includes('Error')) {
                refreshBtn.style.display = 'inline-block';
            } else {
                refreshBtn.style.display = 'none';
            }
            
            // Update language-specific status text if needed
            if (currentLanguage === 'fr') {
                const t = translations.fr;
                if (status === 'Connecting...') text.textContent = t.connecting;
                else if (status === 'Connected') text.textContent = t.connected;
                else if (status === 'Disconnected') text.textContent = t.disconnected;
                else if (status.includes('Failed')) text.textContent = t.failed;
                else if (status.includes('Error')) text.textContent = t.error;
            }
        }

        // Connection state management
        const CONNECTION_STORAGE_KEY = 'tiktok_live_connection_state';
        
        // Load connection state from localStorage
        function loadConnectionState() {
            try {
                const savedState = localStorage.getItem(CONNECTION_STORAGE_KEY);
                if (savedState) {
                    const state = JSON.parse(savedState);
                    console.log('📱 [STATE] Loaded saved connection state:', state);
                    return state;
                }
            } catch (error) {
                console.error('❌ [STATE] Error loading connection state:', error);
            }
            return null;
        }
        
        // Save connection state to localStorage
        function saveConnectionState(state) {
            try {
                localStorage.setItem(CONNECTION_STORAGE_KEY, JSON.stringify(state));
                console.log('💾 [STATE] Saved connection state:', state);
            } catch (error) {
                console.error('❌ [STATE] Error saving connection state:', error);
            }
        }
        
        // Clear connection state from localStorage
        function clearConnectionState() {
            try {
                localStorage.removeItem(CONNECTION_STORAGE_KEY);
                console.log('🗑️ [STATE] Cleared connection state');
            } catch (error) {
                console.error('❌ [STATE] Error clearing connection state:', error);
            }
        }
        
        // Restore connection state on page load
        function restoreConnectionState() {
            const savedState = loadConnectionState();
            if (savedState && savedState.isConnected && savedState.username) {
                console.log('🔄 [STATE] Restoring connection to:', savedState.username);
                
                // Update UI to show connected state
                document.getElementById('usernameInput').value = savedState.username;
                document.getElementById('connectBtn').style.display = 'none';
                document.getElementById('disconnectBtn').style.display = 'inline-block';
                document.getElementById('streamStatus').textContent = 'Reconnecting...';
                document.getElementById('streamerName').textContent = `@${savedState.username}`;
                
                // Attempt to reconnect
                setTimeout(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ 
                            type: 'changeUsername', 
                            username: savedState.username 
                        }));
                        console.log('📤 [STATE] Sent reconnection request for:', savedState.username);
                    } else if (window.httpPollInterval) {
                        connectViaHttp(savedState.username);
                    } else {
                        // Wait for WebSocket connection then reconnect
                        connectWebSocket();
                        setTimeout(() => {
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({ 
                                    type: 'changeUsername', 
                                    username: savedState.username 
                                }));
                            }
                        }, 2000);
                    }
                }, 1000);
            } else {
                console.log('📱 [STATE] No saved connection state, starting fresh');
                updateConnectionUI('disconnected', '');
            }
        }
        
        // Update connection UI based on state
        function updateConnectionUI(state, username = '') {
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const streamStatus = document.getElementById('streamStatus');
            const streamerName = document.getElementById('streamerName');
            const connectionDetails = document.getElementById('connectionDetails');
            
            switch (state) {
                case 'connecting':
                    connectBtn.style.display = 'none';
                    disconnectBtn.style.display = 'inline-block';
                    streamStatus.textContent = 'Connecting...';
                    streamerName.textContent = username ? `@${username}` : '';
                    if (connectionDetails) connectionDetails.style.display = 'none';
                    break;
                    
                case 'connected':
                    connectBtn.style.display = 'none';
                    disconnectBtn.style.display = 'inline-block';
                    streamStatus.textContent = 'Connected';
                    streamerName.textContent = username ? `@${username}` : '';
                    if (connectionDetails) {
                        connectionDetails.style.display = 'flex';
                        updateConnectionDetails(username);
                    }
                    break;
                    
                case 'disconnected':
                    connectBtn.style.display = 'inline-block';
                    disconnectBtn.style.display = 'none';
                    streamStatus.textContent = 'Not connected';
                    streamerName.textContent = '';
                    if (connectionDetails) connectionDetails.style.display = 'none';
                    break;
                    
                case 'error':
                    connectBtn.style.display = 'inline-block';
                    disconnectBtn.style.display = 'none';
                    streamStatus.textContent = 'Connection Error';
                    streamerName.textContent = username ? `@${username}` : '';
                    if (connectionDetails) connectionDetails.style.display = 'none';
                    break;
            }
        }
        
        // Update connection details display
        function updateConnectionDetails(username) {
            const connectionTime = document.getElementById('connectionTime');
            const connectionDuration = document.getElementById('connectionDuration');
            
            if (connectionTime && connectionDuration) {
                const now = new Date();
                const savedState = loadConnectionState();
                
                if (savedState && savedState.timestamp) {
                    const connectionDate = new Date(savedState.timestamp);
                    const duration = Math.floor((now - connectionDate) / 1000);
                    
                    connectionTime.textContent = `🕐 ${connectionDate.toLocaleTimeString()}`;
                    connectionDuration.textContent = `⏱️ ${formatDuration(duration)}`;
                }
            }
        }
        
        // Format duration in human-readable format
        function formatDuration(seconds) {
            if (seconds < 60) return `${seconds}s`;
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return `${hours}h ${minutes}m`;
        }
        
        // Username management functions
        function connectToStream() {
            const username = document.getElementById('usernameInput').value.trim();
            if (!username) {
                alert('Please enter a TikTok username');
                return;
            }
            
            console.log('🔗 [USERNAME] Attempting to connect to:', username);
            
            // Update UI to connecting state
            updateConnectionUI('connecting', username);
            
            // Clear any existing gift queue to prevent overwhelm during connection
            clearGiftQueue();
            
            // Save connection state
            saveConnectionState({
                isConnected: false,
                username: username,
                timestamp: Date.now(),
                status: 'connecting'
            });
            
            // Set connection timeout (60 seconds - increased for slower connections)
            const connectionTimeout = setTimeout(() => {
                console.log('⏰ [USERNAME] Connection timeout reached');
                
                // Update UI to error state
                updateConnectionUI('error', username);
                
                // Update connection state
                saveConnectionState({
                    isConnected: false,
                    username: username,
                    timestamp: Date.now(),
                    status: 'timeout'
                });
                
                alert('Connection timeout. Please check if the username is correct and the user is live streaming.');
            }, 60000);
            
            // Add progress indicator
            document.getElementById('streamStatus').textContent = 'Connecting... (0%)';
            let progressCounter = 0;
            const progressInterval = setInterval(() => {
                progressCounter += 10;
                if (progressCounter <= 90) {
                    document.getElementById('streamStatus').textContent = `Connecting... (${progressCounter}%)`;
                }
            }, 6000); // Update every 6 seconds
            
            // Store both timers for cleanup
            window.connectionTimeout = connectionTimeout;
            window.progressInterval = progressInterval;
            
            // Try WebSocket first, fallback to HTTP if needed
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ 
                    type: 'changeUsername', 
                    username: username 
                }));
                console.log('📤 [USERNAME] Sent username change request via WebSocket:', username);
            } else if (window.httpPollInterval) {
                // HTTP polling mode - use fetch API
                console.log('📤 [USERNAME] Using HTTP mode for username change:', username);
                connectViaHttp(username);
            } else {
                console.log('⚠️ [USERNAME] WebSocket not connected, attempting connection...');
                connectWebSocket();
                // Wait for connection then send username
                setTimeout(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ 
                            type: 'changeUsername', 
                            username: username 
                        }));
                    } else if (window.httpPollInterval) {
                        // Fallback to HTTP if WebSocket still not available
                        connectViaHttp(username);
                    }
                }, 1000);
            }
            
            // Store timeout reference for clearing when connection succeeds
            window.connectionTimeout = connectionTimeout;
        }

        function disconnectFromStream() {
            console.log('❌ [USERNAME] Disconnecting from current stream');
            
            // Update UI to disconnected state
            updateConnectionUI('disconnected', '');
            
            // Clear connection state
            clearConnectionState();
            
            // Clear gift queue when disconnecting
            clearGiftQueue();
            
            // Send disconnect request to server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ 
                    type: 'disconnectStream' 
                }));
            }
            
            // Reset dashboard
            resetDashboardCounters();
        }

        function connectWebSocket() {
            try {
                updateConnectionStatus('Connecting...', '');
                
                // Handle different deployment environments
                let wsUrl;
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    // Local development
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const host = window.location.host;
                    wsUrl = `${protocol}//${host}`;
                } else {
                    // Deployed environment (Render, Heroku, etc.)
                    // Try WebSocket first, fallback to HTTP polling if needed
                    wsUrl = `wss://${window.location.hostname}`;
                }
                
                console.log('🔌 Connecting to WebSocket:', wsUrl);
                ws = new WebSocket(wsUrl);
                
                ws.onopen = function() {
                    console.log('🖥️  Dashboard connected via WebSocket');
                    updateConnectionStatus('Connected', 'connected');
                    reconnectAttempts = 0; // Reset reconnect attempts on successful connection
                    
                    // Initialize question display
                    showNoQuestionsCard();
                    updateQuestionStatsRealTime();
                    
                    // Send test message to verify connection
                    ws.send(JSON.stringify({ type: 'test', data: 'ping' }));
                };
                
                ws.onmessage = function(event) {
                    try {
                        const message = JSON.parse(event.data);
                        console.log('📨 Received message:', message.type);
                        
                        switch (message.type) {
                            case 'metrics':
                                updateMetrics(message.data);
                                break;
                            case 'chat':
                                console.log('💬 Chat message:', message.data);
                                addActivityItem('💬', message.data.nickname, message.data.comment, message.data.sentimentScore, message.data.timestamp);
                                break;
                            case 'like':
                                console.log('❤️ Like event:', message.data);
                                const likeText = message.data.likeCount > 1 ? 
                                    `sent ${message.data.likeCount} likes` : 
                                    'sent a like';
                                addActivityItem('❤️', message.data.nickname, likeText, null, message.data.timestamp);
                                break;
                            case 'gift':
                                console.log('🎁 Gift event:', message.data);
                                const giftName = message.data.gift?.name || message.data.giftName || 'Unknown Gift';
                                const diamondCount = message.data.gift?.diamondCount || message.data.diamondCount || 'unknown';
                                addActivityItem('🎁', message.data.nickname, `sent ${giftName} (${diamondCount} diamonds)`, null, message.data.timestamp);
                                
                                // Show gift alert overlay
                                showGiftAlert(message.data);
                                break;
                            case 'share':
                                console.log('📤 Share event:', message.data);
                                const shareText = message.data.shareCount > 1 ? 
                                    `shared ${message.data.shareCount} times` : 
                                    'shared the stream';
                                addActivityItem('📤', message.data.nickname, shareText, null, message.data.timestamp);
                                break;
                            case 'questionDetected':
                                console.log('❓ Question detected:', message.data);
                                // Add to activity feed
                                addActivityItem('❓', message.data.nickname, `asked: "${message.data.question}"`, null, message.data.timestamp);
                                // Update question detection display
                                updateQuestionDetection({ questionDetection: { 
                                    pendingQuestions: [message.data],
                                    questionStats: { totalQuestions: 1, answeredQuestions: 0, responseRate: 0, averageResponseTime: 0 }
                                }});
                                break;
                            case 'questionAnswered':
                                console.log('✅ Question answered:', message.data);
                                // Update question detection display
                                updateQuestionDetection({ questionDetection: { 
                                    pendingQuestions: [],
                                    questionStats: { totalQuestions: 1, answeredQuestions: 1, responseRate: 100, averageResponseTime: 0 }
                                }});
                                break;
                            case 'automatedPrompt':
                                console.log('🤖 AI Prompt received:', message.data);
                                updateActionablePrompt(message.data);
                                addToPromptHistory(message.data);
                                break;
                            case 'viewerStats':
                                console.log('👥 Viewer stats received:', message.data);
                                updateViewerStats(message.data);
                                
                                // Update Top Engaged Users with latest engagement ranking
                                if (message.data.engagementRanking && message.data.engagementRanking.length > 0) {
                                    console.log('📊 [WEBSOCKET] Updating Top Engaged Users with engagement ranking');
                                    updateTopEngagedUsers(message.data.engagementRanking);
                                } else {
                                    console.log('📊 [WEBSOCKET] No engagement ranking data available');
                                }
                                break;
                            case 'viewerCount':
                                console.log('👥 Viewer count update:', message.data);
                                updateViewerCount(message.data.count);
                                break;
                            case 'newFollower':
                                console.log('🆕 New follower event received:', message.data);
                                addActivityItem('🆕', message.data.nickname, 'started following!', null, message.data.timestamp);
                                updateNewFollowers(message.data);
                                break;
                            case 'usernameChanged':
                                console.log('🔄 Username changed:', message.data);
                                if (message.data && message.data.username) {
                                    // Update UI to connected state
                                    updateConnectionUI('connected', message.data.username);
                                    
                                    // Save successful connection state
                                    saveConnectionState({
                                        isConnected: true,
                                        username: message.data.username,
                                        timestamp: Date.now(),
                                        status: 'connected'
                                    });
                                    
                                    addActivityItem('🔄', 'System', message.data.message || 'Username changed successfully', null, new Date());
                                } else {
                                    console.warn('⚠️ Username changed message missing data:', message);
                                    updateConnectionUI('connected', '');
                                    addActivityItem('🔄', 'System', 'Username changed successfully', null, new Date());
                                }
                                
                                // Clear connection timeout and progress interval
                                if (window.connectionTimeout) {
                                    clearTimeout(window.connectionTimeout);
                                    window.connectionTimeout = null;
                                }
                                if (window.progressInterval) {
                                    clearInterval(window.progressInterval);
                                    window.progressInterval = null;
                                }
                                break;
                            case 'usernameChangeError':
                                console.error('❌ Username change error - Full message:', message);
                                console.error('❌ Username change error - Message data:', message.data);
                                console.error('❌ Username change error - Message type:', message.type);
                                
                                // Try to extract error message from various possible structures
                                let errorMessage = 'Unknown error occurred';
                                if (message.data) {
                                    if (typeof message.data === 'string') {
                                        errorMessage = message.data;
                                    } else if (message.data.error) {
                                        errorMessage = message.data.error;
                                    } else if (message.data.details) {
                                        errorMessage = message.data.details;
                                    } else if (message.data.message) {
                                        errorMessage = message.data.message;
                                    } else {
                                        errorMessage = JSON.stringify(message.data);
                                    }
                                }
                                
                                console.log('🔍 Extracted error message:', errorMessage);
                                alert(`Error changing username: ${errorMessage}`);
                                
                                // Reset UI
                                document.getElementById('connectBtn').style.display = 'inline-block';
                                document.getElementById('disconnectBtn').style.display = 'none';
                                document.getElementById('streamStatus').textContent = 'Error';
                                
                                // Clear connection timeout and progress interval
                                if (window.connectionTimeout) {
                                    clearTimeout(window.connectionTimeout);
                                    window.connectionTimeout = null;
                                }
                                if (window.progressInterval) {
                                    clearInterval(window.progressInterval);
                                    window.progressInterval = null;
                                }
                                break;
                            case 'connectionProgress':
                                console.log('🔄 Connection progress:', message.data);
                                if (message.data && message.data.progress) {
                                    document.getElementById('streamStatus').textContent = `Connecting... (${message.data.progress}%)`;
                                } else {
                                    console.warn('⚠️ Connection progress message missing data:', message);
                                }
                                break;
                                
                            case 'streamDisconnected':
                                console.log('❌ Stream disconnected:', message.data);
                                document.getElementById('streamStatus').textContent = 'Disconnected';
                                document.getElementById('streamerName').textContent = '';
                                if (message.data && message.data.message) {
                                    addActivityItem('❌', 'System', message.data.message, null, new Date());
                                } else {
                                    addActivityItem('❌', 'System', 'Stream disconnected', null, new Date());
                                }
                                break;
                            case 'aiWelcome':
                                console.log('🤖 AI Welcome:', message.data);
                                showAIWelcome(message.data);
                                break;
                            case 'metricsReset':
                                console.log('🔄 Metrics reset:', message.data);
                                const resetTimestamp = message.data && message.data.timestamp ? message.data.timestamp : new Date();
                                addActivityItem('🔄', 'System', 'Live stream metrics reset for new session', null, resetTimestamp);
                                // Reset dashboard counters
                                resetDashboardCounters();
                                break;
                            case 'streamStarted':
                                console.log('🎬 Stream started:', message.data);
                                const startTimestamp = message.data && message.data.timestamp ? message.data.timestamp : new Date();
                                addActivityItem('🎬', 'System', 'Live stream has started - metrics reset', null, startTimestamp);
                                // Reset dashboard counters
                                resetDashboardCounters();
                                // Show notification
                                showNotification('Live stream started! Metrics reset for new session.', 'success');
                                break;
                            default:
                                console.log('📨 Unknown message type:', message.type);
                                console.log('📨 Full message content:', message);
                                console.log('📨 Message data:', message.data);
                                
                                // If it looks like an error message, handle it gracefully
                                if (message.type && message.type.toLowerCase().includes('error')) {
                                    console.error('🚨 Detected error message:', message);
                                    let errorMsg = 'Unknown error occurred';
                                    
                                    if (message.data) {
                                        if (typeof message.data === 'string') {
                                            errorMsg = message.data;
                                        } else if (message.data.error) {
                                            errorMsg = message.data.error;
                                        } else if (message.data.message) {
                                            errorMsg = message.data.message;
                                        } else {
                                            errorMsg = JSON.stringify(message.data);
                                        }
                                    }
                                    
                                    alert(`Error: ${errorMsg}`);
                                }
                        }
                    } catch (error) {
                        console.error('❌ Error parsing message:', error);
                        
                        // Try to handle as error message if it looks like one
                        if (error && typeof error === 'object') {
                            if (error.type && error.type.toLowerCase().includes('error')) {
                                console.error('🚨 Detected error message in catch block:', error);
                                let errorMsg = 'Unknown error occurred';
                                
                                if (error.data) {
                                    if (typeof error.data === 'string') {
                                        errorMsg = error.data;
                                    } else if (error.data.error) {
                                        errorMsg = error.data.error;
                                    } else if (error.data.message) {
                                        errorMsg = error.data.message;
                                    } else {
                                        errorMsg = JSON.stringify(error.data);
                                    }
                                } else if (error.error) {
                                    errorMsg = error.error;
                                } else if (error.message) {
                                    errorMsg = error.message;
                                }
                                
                                alert(`Error: ${errorMsg}`);
                            }
                        }
                    }
                };
                
                ws.onclose = function(event) {
                    console.log(`🖥️  WebSocket disconnected (Code: ${event.code})`);
                    updateConnectionStatus('Disconnected', 'disconnected');
                    
                    if (event.code === 1006) {
                        console.log('⚠️  Abnormal closure detected - attempting reconnection...');
                    }
                    
                    // Attempt to reconnect if not a normal closure
                    if (event.code !== 1000 && reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        console.log(`🔄 Reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts} in ${reconnectDelay/1000}s...`);
                        updateConnectionStatus(`Reconnecting... (${reconnectAttempts}/${maxReconnectAttempts})`, '');
                        
                        setTimeout(() => {
                            connectWebSocket();
                        }, reconnectDelay);
                    } else if (reconnectAttempts >= maxReconnectAttempts) {
                        console.error('❌ Max reconnection attempts reached. Please refresh the page.');
                        updateConnectionStatus('Connection Failed', 'disconnected');
                        showConnectionError();
                    }
                };
                
                ws.onerror = function(error) {
                    console.error('❌ WebSocket error:', error);
                    updateConnectionStatus('Connection Error', 'disconnected');
                    
                    // Check if this is a deployment environment WebSocket issue
                    if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                        console.log('🌐 Detected deployed environment - attempting HTTP fallback...');
                        // Fallback to HTTP polling for deployed environments
                        enableHttpPolling();
                        return;
                    }
                };
                
            } catch (error) {
                console.error('❌ Error creating WebSocket connection:', error);
                updateConnectionStatus('Connection Error', 'disconnected');
                
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    console.log(`🔄 Reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts} in ${reconnectDelay/1000}s...`);
                    
                    setTimeout(() => {
                        connectWebSocket();
                    }, reconnectDelay);
                }
            }
        }

        // Performance monitoring functions
        async function refreshPerformance() {
            try {
                const response = await fetch('/health');
                if (response.ok) {
                    const data = await response.json();
                    
                    // Update performance display
                    document.getElementById('memoryUsage').textContent = data.memory.heapUsed;
                    document.getElementById('uptime').textContent = formatUptime(data.uptime);
                    document.getElementById('activeViewers').textContent = data.metrics.activeViewers;
                    document.getElementById('connectionMode').textContent = ws && ws.readyState === WebSocket.OPEN ? 'WebSocket' : 'HTTP Polling';
                    
                    console.log('📊 [PERFORMANCE] Updated performance metrics:', data);
                }
            } catch (error) {
                console.error('❌ [PERFORMANCE] Failed to fetch performance data:', error);
            }
        }
        
        function formatUptime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return `${hours}h ${minutes}m`;
        }
        
        // Mobile performance optimizations
        function enableMobileOptimizations() {
            if (isMobileDevice()) {
                console.log('📱 [MOBILE] Enabling performance optimizations...');
                
                // Reduce animation complexity on mobile
                document.documentElement.style.setProperty('--animation-duration', '0.3s');
                document.documentElement.style.setProperty('--transition-duration', '0.2s');
                
                // Disable heavy animations on mobile
                const heavyAnimations = document.querySelectorAll('.gauge::before, .entertainment-gauge::before');
                heavyAnimations.forEach(el => {
                    if (el) el.style.animation = 'none';
                });
                
                // Reduce shadow complexity on mobile
                const cards = document.querySelectorAll('.metric-card, .entertainment-gauge');
                cards.forEach(card => {
                    if (card) card.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                });
                
                // Show mobile optimization notice
                showMobileOptimizationNotice();
                
                console.log('📱 [MOBILE] Performance optimizations applied');
            }
        }
        
        // Show mobile optimization notice
        function showMobileOptimizationNotice() {
            const notice = document.createElement('div');
            notice.style.cssText = `
                position: fixed;
                top: 20px;
                left: 20px;
                right: 20px;
                background: linear-gradient(135deg, #ff6b6b, #ff8e53);
                color: white;
                padding: 15px;
                border-radius: 10px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 1000;
                font-family: Arial, sans-serif;
                text-align: center;
                font-size: 14px;
            `;
            notice.innerHTML = `
                📱 <strong>Mobile Mode Active</strong><br>
                Polling optimized for battery life. Data updates every 3-10 seconds.
                <button onclick="this.parentElement.remove()" style="margin-left: 10px; padding: 5px 10px; border: none; background: white; color: #ff6b6b; border-radius: 4px; cursor: pointer; font-size: 12px;">×</button>
            `;
            document.body.appendChild(notice);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (notice.parentElement) {
                    notice.remove();
                }
            }, 10000);
        }
        
        // Toggle performance monitor (Ctrl+Shift+P)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'P') {
                const monitor = document.getElementById('performanceMonitor');
                monitor.style.display = monitor.style.display === 'none' ? 'block' : 'none';
                console.log('🖥️ [PERFORMANCE] Monitor toggled');
            }
        });
        
        // HTTP-based connection for deployed environments
        async function connectViaHttp(username) {
            try {
                console.log('🌐 [HTTP MODE] Connecting to TikTok Live via HTTP API...');
                
                // Update UI to show HTTP mode
                document.getElementById('streamStatus').textContent = 'Connecting via HTTP...';
                
                // Send username change request via HTTP POST
                const response = await fetch('/change-username', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ username: username })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('✅ [HTTP MODE] Username change successful:', result);
                    document.getElementById('streamStatus').textContent = 'Connected (HTTP Mode)';
                    
                    // Clear timers
                    if (window.connectionTimeout) clearTimeout(window.connectionTimeout);
                    if (window.progressInterval) clearInterval(window.progressInterval);
                    
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
            } catch (error) {
                console.error('❌ [HTTP MODE] Connection failed:', error);
                document.getElementById('streamStatus').textContent = 'HTTP Connection Failed';
                document.getElementById('connectBtn').style.display = 'inline-block';
                document.getElementById('disconnectBtn').style.display = 'none';
                alert(`Connection failed: ${error.message}`);
            }
        }
        
        // Mobile detection and optimization
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   window.innerWidth <= 768;
        }
        
        // Battery and performance monitoring
        function getBatteryLevel() {
            if ('getBattery' in navigator) {
                return navigator.getBattery();
            }
            return null;
        }
        
        // HTTP polling fallback for deployed environments where WebSocket fails
        function enableHttpPolling() {
            console.log('🔄 [HTTP FALLBACK] Enabling HTTP polling for deployed environment...');
            updateConnectionStatus('HTTP Polling Mode', 'connected');
            
            // Clear any existing WebSocket connection
            if (ws) {
                ws.close();
                ws = null;
            }
            
            // Mobile-optimized polling intervals
            const isMobile = isMobileDevice();
            const battery = getBatteryLevel();
            
            // Adaptive polling based on device and battery
            let pollIntervalMs = 2000; // Default: 2 seconds
            
            if (isMobile) {
                if (battery && battery.level < 0.2) {
                    pollIntervalMs = 10000; // 10 seconds when battery low
                } else if (battery && battery.level < 0.5) {
                    pollIntervalMs = 5000; // 5 seconds when battery medium
                } else {
                    pollIntervalMs = 3000; // 3 seconds when battery good
                }
                
                // Reduce polling frequency on mobile to save resources
                console.log(`📱 [MOBILE] Optimized polling interval: ${pollIntervalMs}ms`);
            }
            
            // Set up HTTP polling interval with mobile optimization
            const pollInterval = setInterval(async () => {
                try {
                    const response = await fetch('/metrics');
                    if (response.ok) {
                        const data = await response.json();
                        updateMetrics(data);
                        
                        // Only fetch viewer stats on mobile if really needed (less frequent)
                        if (!isMobile || Math.random() < 0.3) { // 30% chance on mobile
                            const viewerResponse = await fetch('/api/viewers');
                            if (viewerResponse.ok) {
                                const viewerData = await viewerResponse.json();
                                if (viewerData.success) {
                                    updateViewerStats(viewerData);
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('❌ [HTTP FALLBACK] Polling error:', error);
                }
            }, pollIntervalMs);
            
            // Store interval for cleanup
            window.httpPollInterval = pollInterval;
            
            // Show info message
            const infoDiv = document.createElement('div');
            infoDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4CAF50;
                color: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 1000;
                font-family: Arial, sans-serif;
            `;
            infoDiv.innerHTML = `
                <strong>HTTP Mode Active</strong><br>
                WebSocket unavailable, using HTTP polling instead.
                <button onclick="this.parentElement.remove()" style="margin-left: 10px; padding: 5px 10px; border: none; background: white; color: #4CAF50; border-radius: 4px; cursor: pointer;">×</button>
            `;
            document.body.appendChild(infoDiv);
        }
        
        function showConnectionError() {
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #ff6b6b;
                color: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 1000;
                font-family: Arial, sans-serif;
            `;
            errorDiv.innerHTML = `
                <strong>Connection Lost</strong><br>
                WebSocket disconnected. Please refresh the page to reconnect.
                <button onclick="this.parentElement.remove()" style="margin-left: 10px; padding: 5px 10px; border: none; background: white; color: #ff6b6b; border-radius: 4px; cursor: pointer;">×</button>
            `;
            document.body.appendChild(errorDiv);
        }

        function sendWebSocketMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            } else {
                console.warn('⚠️  WebSocket not connected, attempting to reconnect...');
                connectWebSocket();
            }
        }

        // Update connection status indicator
        function updateStatus(text, className) {
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            
            indicator.className = `status-indicator ${className}`;
            statusText.textContent = text;
        }

        // Update dashboard metrics
        function updateMetrics(data) {
            // Store current metrics globally for other functions to access
            window.currentMetrics = data;
            
            // Debug log to see what data is received
            console.log('📊 [METRICS] Received data:', {
                totalLikes: data.totalLikes,
                totalGifts: data.totalGifts,
                totalGiftDiamonds: data.totalGiftDiamonds,
                totalGiftValue: data.totalGiftValue,
                totalShares: data.totalShares,
                likesPerMinute: data.likesPerMinute,
                giftsPerMinute: data.giftsPerMinute,
                giftsPerMinuteDiamonds: data.giftsPerMinuteDiamonds,
                giftsPerMinuteValue: data.giftsPerMinuteValue,
                sharesPerMinute: data.sharesPerMinute,
                currentViewerCount: data.currentViewerCount,
                sessionFollowersGained: data.sessionFollowersGained
            });
            
            // Update basic metrics with null checks
        const viewerCountEl = document.getElementById('viewerCount');
        const totalLikesEl = document.getElementById('totalLikes');
        const totalGiftsEl = document.getElementById('totalGifts');
        const totalSharesEl = document.getElementById('totalShares');
        const likesPerMinuteEl = document.getElementById('likesPerMinute');
        const giftsPerMinuteEl = document.getElementById('giftsPerMinute');
        const sharesPerMinuteEl = document.getElementById('sharesPerMinute');
        const followersGainsEl = document.getElementById('followersGains');
        const sentimentScoreEl = document.getElementById('sentimentScore');
        
        // Update Total Gifts value subtitle
        const totalGiftsValueEl = document.getElementById('totalGiftsValue');
        if (totalGiftsValueEl && data.totalGiftValue !== undefined) {
            totalGiftsValueEl.textContent = `$${data.totalGiftValue.toFixed(2)} total value`;
        }

        // Helper function to update metric with animation
        function updateMetricWithAnimation(element, newValue, formatFunction = null) {
            if (!element) return;
            const oldValue = element.textContent;
            const formattedValue = formatFunction ? formatFunction(newValue) : newValue;
            
            if (element.textContent !== formattedValue.toString()) {
                element.textContent = formattedValue;
                element.classList.add('updated');
                setTimeout(() => element.classList.remove('updated'), 600);
            }
        }
        
        // Store previous values for trend calculation
        const prevViewerCount = parseInt(viewerCountEl?.textContent || '0');
        const prevTotalLikes = parseInt(totalLikesEl?.textContent.replace(/,/g, '') || '0');
        const prevTotalGifts = parseInt(totalGiftsEl?.textContent.replace(/,/g, '') || '0');
        const prevTotalShares = parseInt(totalSharesEl?.textContent.replace(/,/g, '') || '0');
        const prevLikesPerMinute = parseInt(likesPerMinuteEl?.textContent || '0');
        const prevGiftsPerMinute = parseInt(giftsPerMinuteEl?.textContent || '0');
        const prevSharesPerMinute = parseInt(sharesPerMinuteEl?.textContent || '0');
        const prevFollowersGains = parseInt(followersGainsEl?.textContent || '0');
        
                    // Update current values with animation
            updateMetricWithAnimation(viewerCountEl, data.currentViewerCount || 0);
            
            // Update activity counters
            updateActivityCounters('viewer', data.currentViewerCount || 0);
            
            // Debug log for per-minute metrics
            console.log('📊 [PER-MINUTE] Updating metrics:', {
                likesPerMinuteEl: !!likesPerMinuteEl,
                giftsPerMinuteEl: !!giftsPerMinuteEl,
                sharesPerMinuteEl: !!sharesPerMinuteEl,
                likesPerMinute: data.likesPerMinute,
                giftsPerMinute: data.giftsPerMinute,
                sharesPerMinute: data.sharesPerMinute
            });
            
            updateMetricWithAnimation(likesPerMinuteEl, data.likesPerMinute || 0);
            updateMetricWithAnimation(giftsPerMinuteEl, data.giftsPerMinute || 0);
            updateMetricWithAnimation(sharesPerMinuteEl, data.sharesPerMinute || 0);
            // Show session total (never decreases) instead of per-minute rate
            console.log('📊 [FOLLOWERS] Updating followers gains element:', {
                element: !!followersGainsEl,
                sessionFollowersGained: data.sessionFollowersGained,
                currentText: followersGainsEl?.textContent
            });
            updateMetricWithAnimation(followersGainsEl, data.sessionFollowersGained || 0);
            
            // Update followers gains session subtitle
            const followersGainsSubtitleEl = document.getElementById('followersGainsSubtitle');
            if (followersGainsSubtitleEl) {
                const sessionTotal = data.sessionFollowersGained || 0;
                followersGainsSubtitleEl.textContent = `${sessionTotal} gained this stream`;
            }
            
            // Update activity counter for followers gains (use session total)
            updateActivityCounters('followersGains', data.sessionFollowersGained || 0);
            if (sentimentScoreEl) sentimentScoreEl.textContent = data.sentimentScore || 0;
            
            // Update trend indicators
            updateMetricTrend('viewerTrend', data.currentViewerCount || 0, prevViewerCount);
            updateMetricTrend('totalLikesTrend', data.totalLikes || 0, prevTotalLikes);
            updateMetricTrend('totalGiftsTrend', data.totalGifts || 0, prevTotalGifts);
            updateMetricTrend('totalSharesTrend', data.totalShares || 0, prevTotalShares);
            updateMetricTrend('likesPerMinuteTrend', data.likesPerMinute || 0, prevLikesPerMinute);
            updateMetricTrend('giftsPerMinuteTrend', data.giftsPerMinute || 0, prevGiftsPerMinute);
            updateMetricTrend('sharesPerMinuteTrend', data.sharesPerMinute || 0, prevSharesPerMinute);
            updateMetricTrend('followersGainsTrend', data.sessionFollowersGained || 0, prevFollowersGains);
            
            // Update Total Likes, Total Gifts, and Total Shares with animation
            updateMetricWithAnimation(totalLikesEl, (data.totalLikes || 0), (val) => val.toLocaleString());
            updateMetricWithAnimation(totalGiftsEl, (data.totalGifts || 0), (val) => val.toLocaleString());
            updateMetricWithAnimation(totalSharesEl, (data.totalShares || 0), (val) => val.toLocaleString());
            
            // Update entertainment gauge
            updateEntertainmentGauge(data.entertainmentMetrics?.entertainmentScore || 0);
            
            // Update viewer stats if available
            if (data.viewerStats) {
                updateViewerStats(data.viewerStats);
            }
            
            // Update entertainment breakdown
            updateEntertainmentBreakdown(data.entertainmentMetrics);
            
            // Update top engaged users with latest viewer stats
            if (data.viewerStats && data.viewerStats.engagementRanking && data.viewerStats.engagementRanking.length > 0) {
                console.log('📊 [METRICS] Updating Top Engaged Users with engagement ranking');
                updateTopEngagedUsers(data.viewerStats.engagementRanking);
            } else if (data.userLikeCounts && Object.keys(data.userLikeCounts).length > 0) {
                console.log('📊 [METRICS] Updating Top Engaged Users with like counts');
                updateTopEngagedUsers(data.userLikeCounts);
            } else {
                console.log('📊 [METRICS] No engagement data available for Top Engaged Users');
                // Don't call updateTopEngagedUsers with empty data
            }
            
            // Update new followers if available (replace entire list to avoid duplicates)
            if (data.newFollowers && data.newFollowers.length > 0) {
                console.log(`🔄 [FOLLOWERS] Received bulk followers update: ${data.newFollowers.length} followers`);
                updateNewFollowersList(data.newFollowers);
            }
            
            // Update AI insights
            updateAIInsights(data);
            
            // Update predictive analytics
            updatePredictiveAnalytics(data);
            
            // Update question detection
            updateQuestionDetection(data);
                }

        // Update metric trend indicators with arrows and enhanced animations
        function updateMetricTrend(trendId, currentValue, previousValue) {
            const trendEl = document.getElementById(trendId);
            if (!trendEl) return;
            
            // Remove existing trend classes
            trendEl.classList.remove('increase', 'decrease', 'stable');
            
            // Add a small delay to ensure smooth transitions
            setTimeout(() => {
                if (currentValue > previousValue) {
                    trendEl.innerHTML = `
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M7 14L12 9L17 14" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    `;
                    trendEl.classList.add('increase');
                    // Trigger animation
                    trendEl.style.animation = 'none';
                    trendEl.offsetHeight; // Trigger reflow
                    trendEl.style.animation = null;
                } else if (currentValue < previousValue) {
                    trendEl.innerHTML = `
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M7 10L12 15L17 10" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    `;
                    trendEl.classList.add('decrease');
                    // Trigger animation
                    trendEl.style.animation = 'none';
                    trendEl.offsetHeight; // Trigger reflow
                    trendEl.style.animation = null;
                } else {
                    trendEl.innerHTML = `
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M5 12H19" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    `;
                    trendEl.classList.add('stable');
                    // Trigger animation
                    trendEl.style.animation = 'none';
                    trendEl.offsetHeight; // Trigger reflow
                    trendEl.style.animation = null;
                }
            }, 50);
        }

        // Reset dashboard counters when metrics are reset
        function resetDashboardCounters() {
            console.log('🔄 [DASHBOARD] Resetting dashboard counters...');
            
            // Reset activity counters
            activityCounters.comments = 0;
            activityCounters.likes = 0;
            activityCounters.gifts = 0;
            activityCounters.viewers = 0;
            activityCounters.totalLikes = 0;
            activityCounters.totalGifts = 0;
            activityCounters.followersGains = 0;
            
            // Update activity summary display
            updateActivitySummary();
            
            // Clear activity feed
            activityItems = [];
            updateActivityDisplay();
            
            // Reset viewers display
            updateViewersDisplay({});
            
            // Clear new followers display
            const newFollowersElement = document.getElementById('newFollowers');
            if (newFollowersElement) {
                newFollowersElement.innerHTML = '';
                console.log('🔄 [DASHBOARD] Cleared new followers display');
            }
            
            // Reset question tracking and display
            pendingQuestions = [];
            currentQuestionIndex = 0;
            window.totalQuestionsProcessed = 0;
            window.totalResponseTime = 0;
            window.averageResponseTime = 0;
            window.processedQuestionIds.clear(); // Clear processed question tracking
            showNoQuestionsCard();
            updateQuestionStatsRealTime();
            
            console.log('✅ [DASHBOARD] Dashboard counters reset complete');
        }



        // Show notification function
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 1000;
                font-family: Arial, sans-serif;
                font-weight: 500;
                max-width: 300px;
                word-wrap: break-word;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }

        // Update entertainment gauge visualization
        function updateEntertainmentGauge(score) {
            const scoreDisplay = document.getElementById('entertainmentScore');
            const entertainmentLabel = document.getElementById('entertainmentLabel');
            const progressFill = document.getElementById('progressFill');
            
            if (!scoreDisplay || !entertainmentLabel || !progressFill) return;
            
            // Update score display with animation
            scoreDisplay.style.transform = 'scale(1.1)';
            scoreDisplay.textContent = score;
            setTimeout(() => {
                scoreDisplay.style.transform = 'scale(1)';
            }, 150);
            
            // Update progress bar
            progressFill.style.width = `${score}%`;
            
            // Update entertainment label based on score
            let label = 'Neutral';
            
            if (score >= 80) {
                label = '🔥 Fire!';
            } else if (score >= 60) {
                label = '🎉 Entertaining';
            } else if (score >= 40) {
                label = '😊 Good';
            } else if (score >= 20) {
                label = '😐 Meh';
            } else {
                label = '😴 Boring';
            }
            
            entertainmentLabel.textContent = label;
            
            // Update active marker
            updateActiveMarker(score);
            
            // Add color transition effect
            scoreDisplay.style.transition = 'all 0.4s ease';
            entertainmentLabel.style.transition = 'all 0.4s ease';
        }

        // Update active marker on progress bar
        function updateActiveMarker(score) {
            const markers = document.querySelectorAll('.marker');
            markers.forEach(marker => marker.classList.remove('active'));
            
            if (score >= 80) {
                document.querySelector('.marker.fire').classList.add('active');
            } else if (score >= 60) {
                document.querySelector('.marker.entertaining').classList.add('active');
            } else if (score >= 40) {
                document.querySelector('.marker.good').classList.add('active');
            } else if (score >= 20) {
                document.querySelector('.marker.meh').classList.add('active');
            } else {
                document.querySelector('.marker.boring').classList.add('active');
            }
        }

        // Update viewer watch time statistics
        function updateViewerStats(data) {
            // Update main stats
            const totalUniqueEl = document.getElementById('totalUniqueViewers');
            const averageWatchTimeEl = document.getElementById('averageWatchTime');
            const longestWatchTimeEl = document.getElementById('longestWatchTime');
            
            if (totalUniqueEl) totalUniqueEl.textContent = data.totalUniqueViewers || 0;
            if (averageWatchTimeEl) averageWatchTimeEl.textContent = formatWatchTime(data.averageWatchTime || 0);
            if (longestWatchTimeEl) longestWatchTimeEl.textContent = formatWatchTime(data.longestWatchTime || 0);
            
            // Update viewer retention rate
            updateViewerRetentionRate();
            

        }

        // Update viewer count display
        function updateViewerCount(count) {
            const viewerCountEl = document.getElementById('viewerCount');
            if (viewerCountEl) {
                viewerCountEl.textContent = count.toLocaleString();
                
                // Add animation effect
                viewerCountEl.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    viewerCountEl.style.transform = 'scale(1)';
                }, 150);
            }
            
            // Update viewer retention rate when viewer count changes
            updateViewerRetentionRate();
        }
        
        // Update viewer retention rate display
        function updateViewerRetentionRate() {
            const viewerRetentionRateEl = document.getElementById('viewerRetentionRate');
            if (!viewerRetentionRateEl) return;
            
            // Get total unique viewers (all-time impressions) and current live viewers
            const totalUniqueViewers = window.currentMetrics?.viewerStats?.totalUniqueViewers || 0;
            const currentViewers = window.currentMetrics?.currentViewerCount || 0;
            
            if (currentViewers > 0 && totalUniqueViewers > 0) {
                // Calculate retention as: (Current Viewers / Total Unique Viewers) × 100
                // This shows what % of people who have seen your stream are currently watching
                const retentionRate = Math.round((currentViewers / totalUniqueViewers) * 100);
                viewerRetentionRateEl.textContent = `${retentionRate}%`;
                
                // Color coding based on retention rate
                if (retentionRate >= 20) {
                    viewerRetentionRateEl.style.color = '#00E676'; // Green for high retention
                } else if (retentionRate >= 10) {
                    viewerRetentionRateEl.style.color = '#FFAA00'; // Orange for medium retention
                } else {
                    viewerRetentionRateEl.style.color = '#FF4444'; // Red for low retention
                }
                
                // Debug logging
                console.log('📊 [RETENTION] Calculation:', {
                    totalUniqueViewers,
                    currentViewers,
                    retentionRate: `${retentionRate}%`,
                    explanation: 'Percentage of total unique viewers currently watching'
                });
            } else {
                viewerRetentionRateEl.textContent = '0%';
                viewerRetentionRateEl.style.color = '#FF4444';
            }
        }

        // Format watch time for display
        function formatWatchTime(seconds) {
            if (seconds < 60) {
                return `${seconds}s`;
            } else if (seconds < 3600) {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes}m ${remainingSeconds}s`;
            } else {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                return `${hours}h ${minutes}m`;
            }
        }

        // Global variables for slideshow
        let currentQuestionIndex = 0;
        let pendingQuestions = [];

        // Global variables for activity management
        let maxActivityItems = 20;
        let activityPaused = false;
        let activityItems = [];
        
        // Pagination for activity feed
        let currentActivityPage = 0;
        let totalActivityPages = 0;
        let activityCounters = {
            comments: 0,
            likes: 0,
            gifts: 0,
            shares: 0,
            viewers: 0,
            totalLikes: 0,
            totalGifts: 0,
            followersGains: 0
        };

        // Update question detection display
        function updateQuestionDetection(data) {
            if (!data.questionDetection) return;
            
            // Check if question action protection is active
            if (questionActionProtection) {
                console.log('🛡️ [QUESTIONS] Metrics update blocked by question action protection');
                return;
            }
            
            const stats = data.questionDetection.questionStats;
            const questions = data.questionDetection.pendingQuestions || [];
            
            // Update stats (but respect local tracking when questions are being processed)
            const totalQuestionsEl = document.getElementById('totalQuestions');
            const responseRateEl = document.getElementById('responseRate');
            const avgResponseTimeEl = document.getElementById('avgResponseTime');
            const currentPriorityEl = document.getElementById('currentPriority');
            
            // Only update stats if we're not in protection mode (to avoid overriding local tracking)
            if (!questionActionProtection) {
                if (totalQuestionsEl) totalQuestionsEl.textContent = stats.totalQuestions || 0;
                if (responseRateEl) responseRateEl.textContent = `${Math.round(stats.responseRate || 0)}%`;
                if (avgResponseTimeEl) avgResponseTimeEl.textContent = `${Math.round((stats.averageResponseTime || 0) / 1000)}s`;
            } else {
                // Use local tracking when protection is active
                updateQuestionStatsRealTime();
            }
            
            // Update current priority if there are pending questions
            if (currentPriorityEl && pendingQuestions.length > 0) {
                const currentQuestion = pendingQuestions[currentQuestionIndex];
                if (currentQuestion) {
                    currentPriorityEl.textContent = getPriorityText(currentQuestion.priority);
                }
            }
            
            // Smart merge: preserve local question state and only add new questions
            const newQuestions = questions.reverse(); // Reverse to show latest first
            
            // Use the new helper function for both cases
            console.log('🔄 [QUESTIONS] Processing new questions with smart merge');
            console.log(`🔄 [QUESTIONS] Local questions: ${pendingQuestions.length}, New questions: ${newQuestions.length}`);
            
            // Add new questions safely using the helper function
            const addedCount = addNewQuestions(newQuestions);
            
            console.log(`📊 [QUESTIONS] Smart merge complete: ${addedCount} new questions added`);
            
            // Only reset index if we have no questions or if current index is out of bounds
            if (pendingQuestions.length === 0 || currentQuestionIndex >= pendingQuestions.length) {
                currentQuestionIndex = 0;
            }
            
            updateQuestionSlideshow();
            
            // Start auto-advance for all questions
            if (pendingQuestions.length > 0) {
                startAutoAdvance();
                // Ensure the display shows the first question immediately
                if (currentQuestionIndex === 0) {
                    displayCurrentQuestion();
                }
                
                // Force a refresh to ensure questions are visible
                setTimeout(() => {
                    updateQuestionSlideshow();
                }, 100);
            } else {
                stopAutoAdvance();
            }
        }

        // Update pending questions display
        // Update question slideshow
        function updateQuestionSlideshow() {
            if (!pendingQuestions || pendingQuestions.length === 0) {
                showNoQuestionsCard();
                return;
            }
            
            // Ensure current index is valid
            if (currentQuestionIndex >= pendingQuestions.length) {
                currentQuestionIndex = 0;
            }
            
            // Display the current question
            displayCurrentQuestion();
            
            // Update question counter
            updateQuestionCounter();
            
            // Update question stats display
            updateQuestionStatsDisplay();
        }
        
        // Update question stats display
        function updateQuestionStatsDisplay() {
            if (pendingQuestions.length === 0) return;
            
            const currentQuestion = pendingQuestions[currentQuestionIndex];
            if (!currentQuestion) return;
            
            // Update current priority
            const currentPriorityEl = document.getElementById('currentPriority');
            if (currentPriorityEl) {
                currentPriorityEl.textContent = getPriorityText(currentQuestion.priority);
            }
            
            // Update question stats in real-time
            updateQuestionStatsRealTime();
        }
        
        // Update question stats in real-time
        function updateQuestionStatsRealTime() {
            const totalQuestionsEl = document.getElementById('totalQuestions');
            const responseRateEl = document.getElementById('responseRate');
            const avgResponseTimeEl = document.getElementById('avgResponseTime');
            
            if (totalQuestionsEl) {
                totalQuestionsEl.textContent = pendingQuestions.length;
            }
            
            // Calculate response rate based on answered questions (tracked separately)
            if (responseRateEl) {
                // Get total questions processed (pending + answered + ignored)
                const totalProcessed = (window.totalQuestionsProcessed || 0) + pendingQuestions.length;
                const answeredCount = window.totalQuestionsProcessed || 0;
                
                if (totalProcessed > 0) {
                    const responseRate = Math.round((answeredCount / totalProcessed) * 100);
                    responseRateEl.textContent = `${responseRate}%`;
                } else {
                    responseRateEl.textContent = '0%';
                }
            }
            
            // Calculate average response time
            if (avgResponseTimeEl) {
                if (window.averageResponseTime) {
                    avgResponseTimeEl.textContent = `${Math.round(window.averageResponseTime)}s`;
                } else {
                    avgResponseTimeEl.textContent = '0s';
                }
            }
            
            // Update auto-advance status
            updateAutoAdvanceStatus();
            
            // Show protection status if active
            showProtectionStatus();
        }
        
        // Show protection status indicator
        function showProtectionStatus() {
            const totalQuestionsEl = document.getElementById('totalQuestions');
            if (!totalQuestionsEl) return;
            
            if (questionActionProtection) {
                totalQuestionsEl.style.color = '#FFAA00'; // Orange to show protection active
                totalQuestionsEl.title = 'Question action in progress - metrics protected';
            } else {
                totalQuestionsEl.style.color = '#ffd700'; // Normal gold color
                totalQuestionsEl.title = 'Total pending questions';
            }
        }
        
        // Debug function to log current question state
        function logQuestionState(action = 'Unknown') {
            console.log(`🔍 [QUESTIONS] State after ${action}:`, {
                protectionActive: questionActionProtection,
                pendingQuestionsCount: pendingQuestions.length,
                currentIndex: currentQuestionIndex,
                questions: pendingQuestions.map(q => ({
                    id: q.id,
                    nickname: q.nickname,
                    question: q.question.substring(0, 50) + '...'
                }))
            });
        }
        
        // Update auto-advance status display
        function updateAutoAdvanceStatus() {
            const statusEl = document.getElementById('autoAdvanceStatus');
            if (!statusEl) return;
            
            if (pendingQuestions.length === 0) {
                statusEl.textContent = 'No pending questions';
                statusEl.style.color = '#9E9E9E';
            } else if (pendingQuestions.length === 1) {
                statusEl.textContent = 'Last question remaining';
                statusEl.style.color = '#FFAA00';
            } else {
                statusEl.textContent = `Auto-advancing questions (${pendingQuestions.length} remaining)`;
                statusEl.style.color = '#00E676';
            }
        }
        
        // Update question counter display
        function updateQuestionCounter() {
            const counterEl = document.getElementById('questionCounter');
            if (counterEl && pendingQuestions.length > 0) {
                counterEl.textContent = `${currentQuestionIndex + 1} / ${pendingQuestions.length}`;
            } else if (counterEl) {
                counterEl.textContent = '0 / 0';
            }
        }

        // Helper functions for question display
        function getPriorityColor(priority) {
            switch (priority) {
                case 5: return '#ff4444'; // Critical
                case 4: return '#ff8800'; // High
                case 3: return '#ffaa00'; // Medium-High
                case 2: return '#8BC34A'; // Medium
                default: return '#9E9E9E'; // Low
            }
        }

        function getPriorityText(priority) {
            switch (priority) {
                case 5: return '🔥 Critical';
                case 4: return '⚡ High';
                case 3: return '📊 Medium-High';
                case 2: return '📝 Medium';
                default: return '💭 Low';
            }
        }

        function getTimeAgo(timestamp) {
            const now = new Date();
            const time = new Date(timestamp);
            const diffMs = now - time;
            const diffMins = Math.floor(diffMs / 60000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            const diffHours = Math.floor(diffMins / 60);
            return `${diffHours}h ago`;
        }

        // Question slideshow functions
        function displayCurrentQuestion() {
            if (!pendingQuestions || pendingQuestions.length === 0) return;
            
            const question = pendingQuestions[currentQuestionIndex];
            if (!question) return;
            
            // Update question card elements
            const priorityBadge = document.getElementById('priorityBadge');
            const viewerName = document.getElementById('viewerName');
            const questionText = document.getElementById('questionText');
            const answerBtn = document.getElementById('answerBtn');
            const ignoreBtn = document.getElementById('ignoreBtn');
            
            if (priorityBadge) priorityBadge.textContent = getPriorityText(question.priority);
            if (viewerName) viewerName.textContent = question.nickname;
            if (questionText) questionText.textContent = question.question;
            
            // Enable buttons when there's a question to display
            if (answerBtn) answerBtn.disabled = false;
            if (ignoreBtn) ignoreBtn.disabled = false;
            
            // Start timer
            startQuestionTimer(question.timestamp);
            
            // Update counter
            updateQuestionCounter();
        }



        function startQuestionTimer(timestamp) {
            const timerEl = document.getElementById('questionTimer');
            if (!timerEl) return;
            
            const updateTimer = () => {
                const now = new Date();
                const time = new Date(timestamp);
                const diffMs = now - time;
                const diffMins = Math.floor(diffMs / 60000);
                
                if (diffMins < 1) timerEl.textContent = 'Just now';
                else if (diffMins < 60) timerEl.textContent = `${diffMins}m ago`;
                else {
                    const diffHours = Math.floor(diffMins / 60);
                    timerEl.textContent = `${diffHours}h ago`;
                }
            };
            
            updateTimer();
            
            // Clear any existing interval and set new one
            if (window.questionTimerInterval) {
                clearInterval(window.questionTimerInterval);
            }
            window.questionTimerInterval = setInterval(updateTimer, 30000); // Update every 30 seconds
        }

        function updateQuestionCounter() {
            const counterEl = document.getElementById('questionCounter');
            if (counterEl && pendingQuestions.length > 0) {
                counterEl.textContent = `${currentQuestionIndex + 1} / ${pendingQuestions.length}`;
            } else if (counterEl) {
                counterEl.textContent = '0 / 0';
            }
        }

        function showNoQuestionsCard() {
            const questionText = document.getElementById('questionText');
            const priorityBadge = document.getElementById('priorityBadge');
            const viewerName = document.getElementById('viewerName');
            const answerBtn = document.getElementById('answerBtn');
            const ignoreBtn = document.getElementById('ignoreBtn');
            
            if (questionText) questionText.textContent = 'No pending questions...';
            if (priorityBadge) priorityBadge.textContent = '-';
            if (viewerName) viewerName.textContent = '-';
            if (answerBtn) answerBtn.disabled = true;
            if (ignoreBtn) ignoreBtn.disabled = true;
            
            // Update counter
            const counterEl = document.getElementById('questionCounter');
            if (counterEl) counterEl.textContent = '0 / 0';
            
            // Clear protection when no questions
            if (questionActionProtection) {
                questionActionProtection = false;
                if (questionActionTimeout) {
                    clearTimeout(questionActionTimeout);
                    questionActionTimeout = null;
                }
                console.log('🛡️ [QUESTIONS] Protection cleared - no questions remaining');
            }
        }

        // Auto-advance to next question
        function advanceToNextQuestion() {
            console.log('🔍 [QUESTIONS] advanceToNextQuestion called:', { currentIndex: currentQuestionIndex, totalQuestions: pendingQuestions.length });
            
            if (pendingQuestions.length === 0) return;
            
            if (currentQuestionIndex < pendingQuestions.length - 1) {
                currentQuestionIndex++;
                console.log('✅ [QUESTIONS] Advanced to next question, new index:', currentQuestionIndex);
            } else {
                // All questions processed, reset to first
                currentQuestionIndex = 0;
                console.log('🔄 [QUESTIONS] All questions processed, reset to first');
            }
            
            displayCurrentQuestion();
            updateQuestionCounter();
            
            // Also update the stats to reflect the current question
            updateQuestionStatsRealTime();
        }



        // Auto-advance functionality
        function startAutoAdvance() {
            if (window.autoAdvanceInterval) {
                clearInterval(window.autoAdvanceInterval);
            }
            
            // Auto-advance every 8 seconds to give streamer time to read and act
            window.autoAdvanceInterval = setInterval(() => {
                if (pendingQuestions.length > 0) {
                    advanceToNextQuestion();
                }
            }, 8000); // 8 seconds per question
        }

        function stopAutoAdvance() {
            if (window.autoAdvanceInterval) {
                clearInterval(window.autoAdvanceInterval);
                window.autoAdvanceInterval = null;
            }
        }



        // Protection mechanism to prevent metrics from overriding question actions
        let questionActionProtection = false;
        let questionActionTimeout = null;
        
        // Question tracking variables for better stats
        window.totalQuestionsProcessed = 0;
        window.totalResponseTime = 0;
        window.averageResponseTime = 0;
        window.processedQuestionIds = new Set(); // Track processed question IDs to avoid duplicates
        
        // Initialize question stats display
        function initializeQuestionStats() {
            updateQuestionStatsRealTime();
        }

        // Function to check if a question is new and should be added
        function shouldAddQuestion(newQuestion) {
            // Check if question already exists in pending questions
            const existsLocally = pendingQuestions.some(localQuestion => 
                localQuestion.id === newQuestion.id
            );
            
            // Check if question has already been processed
            const alreadyProcessed = window.processedQuestionIds.has(newQuestion.id);
            
            return !existsLocally && !alreadyProcessed;
        }

        // Function to add new questions safely
        function addNewQuestions(newQuestions) {
            let addedCount = 0;
            
            newQuestions.forEach(newQuestion => {
                if (shouldAddQuestion(newQuestion)) {
                    pendingQuestions.push(newQuestion);
                    addedCount++;
                    console.log(`➕ [QUESTIONS] Added new question: ${newQuestion.nickname}`);
                } else {
                    console.log(`⏭️ [QUESTIONS] Skipping question: ${newQuestion.nickname} (exists: ${!shouldAddQuestion(newQuestion)})`);
                }
            });
            
            if (addedCount > 0) {
                // Sort by timestamp to maintain order
                pendingQuestions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                console.log(`📊 [QUESTIONS] Added ${addedCount} new questions, total pending: ${pendingQuestions.length}`);
                
                // Update display
                updateQuestionSlideshow();
                
                // Force a refresh to ensure new questions are visible
                setTimeout(() => {
                    updateQuestionSlideshow();
                }, 200);
            }
            
            return addedCount;
        }
        
        // Call initialization when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Load language preference first
            loadLanguagePreference();
            
            initializeQuestionStats();
            showNoQuestionsCard(); // Ensure question display is initialized
            
            // Initialize gift management panel
            updateGiftManagementPanel();
            
            // Initialize viewer counter
            updateViewerCounter();
        });

        // Question action functions
        function markQuestionAnswered(questionId = null) {
            console.log('🔍 [QUESTIONS] markQuestionAnswered called with:', { questionId, pendingQuestionsLength: pendingQuestions.length, currentIndex: currentQuestionIndex });
            
            // Set protection flag to prevent metrics override
            questionActionProtection = true;
            
            // Clear existing timeout
            if (questionActionTimeout) {
                clearTimeout(questionActionTimeout);
            }
            
            // Set protection timeout (5 seconds) - extended for better reliability
            questionActionTimeout = setTimeout(() => {
                questionActionProtection = false;
                console.log('🛡️ [QUESTIONS] Protection expired, metrics can now update');
            }, 5000);
            
            if (pendingQuestions.length === 0) {
                console.log('❌ [QUESTIONS] No pending questions to mark as answered');
                return;
            }
            
            let questionIndex = currentQuestionIndex;
            if (questionId) {
                // Find question by ID if provided
                questionIndex = pendingQuestions.findIndex(q => q.id === questionId);
                if (questionIndex === -1) {
                    console.log('❌ [QUESTIONS] Question ID not found:', questionId);
                    return;
                }
            }
            
            const question = pendingQuestions[questionIndex];
            console.log(`✅ [QUESTIONS] Marking question from ${question.nickname} as answered`);
            
            // Track response time and update stats
            const responseTime = Math.floor((Date.now() - new Date(question.timestamp)) / 1000);
            window.totalQuestionsProcessed++;
            window.totalResponseTime += responseTime;
            window.averageResponseTime = window.totalResponseTime / window.totalQuestionsProcessed;
            
            // Mark this question as processed
            window.processedQuestionIds.add(question.id);
            
            // Remove the answered question
            pendingQuestions.splice(questionIndex, 1);
            
            // Update display and stats immediately
            if (pendingQuestions.length === 0) {
                showNoQuestionsCard();
                stopAutoAdvance();
            } else {
                // Adjust current index if needed
                if (currentQuestionIndex >= pendingQuestions.length) {
                    currentQuestionIndex = pendingQuestions.length - 1;
                }
                // Update the display with the new current question
                updateQuestionSlideshow();
                
                // Continue auto-advance for remaining questions
                startAutoAdvance();
            }
            
            // Update stats display immediately
            updateQuestionStatsRealTime();
            
            // Force a display refresh to ensure everything is updated
            setTimeout(() => {
                updateQuestionSlideshow();
            }, 100);
            
            // Log state after action
            logQuestionState('markQuestionAnswered');
        }

        function ignoreQuestion(questionId = null) {
            console.log('🔍 [QUESTIONS] ignoreQuestion called with:', { questionId, pendingQuestionsLength: pendingQuestions.length, currentIndex: currentQuestionIndex });
            
            // Set protection flag to prevent metrics override
            questionActionProtection = true;
            
            // Clear existing timeout
            if (questionActionTimeout) {
                clearTimeout(questionActionTimeout);
            }
            
            // Set protection timeout (5 seconds) - extended for better reliability
            questionActionTimeout = setTimeout(() => {
                questionActionProtection = false;
                console.log('🛡️ [QUESTIONS] Protection expired, metrics can now update');
            }, 5000);
            
            if (pendingQuestions.length === 0) {
                console.log('❌ [QUESTIONS] No pending questions to ignore');
                return;
            }
            
            let questionIndex = currentQuestionIndex;
            if (questionId) {
                // Find question by ID if provided
                questionIndex = pendingQuestions.findIndex(q => q.id === questionId);
                if (questionIndex === -1) {
                    console.log('❌ [QUESTIONS] Question ID not found:', questionId);
                    return;
                }
            }
            
            const question = pendingQuestions[questionIndex];
            console.log(`❌ [QUESTIONS] Ignoring question from ${question.id} from ${question.nickname}`);
            
            // Track ignored question for stats
            window.totalQuestionsProcessed++;
            
            // Mark this question as processed
            window.processedQuestionIds.add(question.id);
            
            // Remove the ignored question
            pendingQuestions.splice(questionIndex, 1);
            
            // Update display and stats immediately
            if (pendingQuestions.length === 0) {
                showNoQuestionsCard();
                stopAutoAdvance();
            } else {
                // Adjust current index if needed
                if (currentQuestionIndex >= pendingQuestions.length) {
                    currentQuestionIndex = pendingQuestions.length - 1;
                }
                // Update the display with the new current question
                updateQuestionSlideshow();
                
                // Continue auto-advance for remaining questions
                startAutoAdvance();
            }
            
            // Update stats display immediately
            updateQuestionStatsRealTime();
            
            // Force a display refresh to ensure everything is updated
            setTimeout(() => {
                updateQuestionSlideshow();
            }, 100);
            
            // Log state after action
            logQuestionState('ignoreQuestion');
        }
        
        // Handler functions for onclick buttons
        function handleQuestionAnswered() {
            if (pendingQuestions.length === 0) {
                console.log('❌ [QUESTIONS] No questions to answer');
                return;
            }
            
            const currentQuestion = pendingQuestions[currentQuestionIndex];
            if (currentQuestion) {
                markQuestionAnswered(currentQuestion.id);
            } else {
                console.log('❌ [QUESTIONS] No current question to answer');
            }
        }
        
        function handleQuestionIgnored() {
            if (pendingQuestions.length === 0) {
                console.log('❌ [QUESTIONS] No questions to ignore');
                return;
            }
            
            const currentQuestion = pendingQuestions[currentQuestionIndex];
            if (currentQuestion) {
                ignoreQuestion(currentQuestion.id);
            } else {
                console.log('❌ [QUESTIONS] No current question to ignore');
            }
        }

        // ===== SMART ACTIVITY MANAGEMENT =====

        // Update activity counters
        function updateActivityCounters(type, count = 1) {
            if (activityPaused) return;
            
            switch (type) {
                case 'comment':
                    activityCounters.comments += count;
                    break;
                case 'like':
                    activityCounters.likes += count;
                    break;
                case 'gift':
                    activityCounters.gifts += count;
                    break;
                case 'share':
                    activityCounters.shares += count;
                    break;
                case 'viewer':
                    activityCounters.viewers = count; // Set absolute value
                    break;
                case 'totalLikes':
                    activityCounters.totalLikes = count; // Set absolute value
                    break;
                case 'totalGifts':
                    activityCounters.totalGifts = count; // Set absolute value
                    break;
                case 'followersGains':
                    const previousCount = activityCounters.followersGains;
                    activityCounters.followersGains = count; // Set absolute value
                    
                    // Trigger green lights effect if session followers increased
                    if (count > previousCount) {
                        triggerFollowersGlowEffect();
                    }
                    break;

            }
            
            updateActivitySummary();
        }

        // Trigger green lights effect for followers gains
        function triggerFollowersGlowEffect() {
            const followersGainsEl = document.getElementById('followersGains');
            const followersCard = followersGainsEl?.closest('.metric-card');
            
            if (followersGainsEl && followersCard) {
                // Add green glow class
                followersGainsEl.classList.add('green-glow');
                
                // Add shimmer effect to card
                followersCard.classList.add('shimmer');
                
                // Remove effects after animation completes
                setTimeout(() => {
                    followersGainsEl.classList.remove('green-glow');
                    followersCard.classList.remove('shimmer');
                }, 2000); // Match animation duration
            }
        }

        // Update activity summary display
        function updateActivitySummary() {
            const commentCountEl = document.getElementById('commentCount');
            const likeCountEl = document.getElementById('likeCount');
            const giftCountEl = document.getElementById('giftCount');
            const shareCountEl = document.getElementById('shareCount');
            const viewerCountEl = document.getElementById('viewerCount');
            const followersGainsCountEl = document.getElementById('followersGainsCount');
            
            if (commentCountEl) commentCountEl.textContent = activityCounters.comments;
            if (likeCountEl) likeCountEl.textContent = activityCounters.likes;
            if (giftCountEl) giftCountEl.textContent = activityCounters.gifts;
            if (shareCountEl) shareCountEl.textContent = activityCounters.shares;
            if (viewerCountEl) viewerCountEl.textContent = activityCounters.viewers;
            if (followersGainsCountEl) followersGainsCountEl.textContent = activityCounters.followersGains;
        }

        // Smart activity item management with memory optimization
        const MAX_ACTIVITY_ITEMS = 200; // Limit total stored items
        const ACTIVITY_CLEANUP_INTERVAL = 5 * 60 * 1000; // Cleanup every 5 minutes
        
        function addActivityItem(icon, nickname, content, sentiment = null, timestamp = null) {
            if (activityPaused) return;
            
            const activityItem = {
                id: Date.now() + Math.random(),
                icon: icon,
                nickname: nickname,
                content: content,
                sentiment: sentiment,
                timestamp: timestamp || new Date(),
                type: getActivityType(icon)
            };
            
            // Add to activity items array with memory management
            activityItems.unshift(activityItem);
            
            // Limit total items to prevent memory issues
            if (activityItems.length > MAX_ACTIVITY_ITEMS) {
                // Remove oldest items, keeping only the most recent
                activityItems = activityItems.slice(0, MAX_ACTIVITY_ITEMS);
                console.log('🧹 [ACTIVITY] Cleaned up old activity items, kept latest', MAX_ACTIVITY_ITEMS);
            }
            
            // Update display (debounced for performance)
            debounceUpdateActivityDisplay();
            
            // Update counters
            updateActivityCounters(activityItem.type);
        }
        
        // Debounced display update for better performance
        let activityDisplayTimeout = null;
        function debounceUpdateActivityDisplay() {
            if (activityDisplayTimeout) {
                clearTimeout(activityDisplayTimeout);
            }
            activityDisplayTimeout = setTimeout(() => {
                updateActivityDisplay();
                activityDisplayTimeout = null;
            }, 100); // 100ms debounce
        }
        
        // Performance monitoring and automatic cleanup
        function startActivityCleanup() {
            setInterval(() => {
                const currentTime = new Date();
                const oneHourAgo = new Date(currentTime.getTime() - 60 * 60 * 1000);
                
                // Remove old activity items to free memory
                const initialLength = activityItems.length;
                activityItems = activityItems.filter(item => {
                    const itemTime = new Date(item.timestamp);
                    return itemTime > oneHourAgo;
                });
                
                const removedCount = initialLength - activityItems.length;
                if (removedCount > 0) {
                    console.log(`🧹 [ACTIVITY] Cleaned up ${removedCount} old activity items`);
                    
                    // Update display if items were removed
                    debounceUpdateActivityDisplay();
                }
                
                // Log memory usage for monitoring
                if (activityItems.length > 150) {
                    console.warn(`⚠️ [ACTIVITY] High activity count: ${activityItems.length}/${MAX_ACTIVITY_ITEMS}`);
                }
            }, ACTIVITY_CLEANUP_INTERVAL);
        }
        
        // Alternative: Lightweight activity summary instead of full feed
        function addActivitySummary(icon, nickname, content, type = 'other') {
            // Only add summary for high-priority activities
            if (type === 'gift' || type === 'comment' || icon === '🤖' || icon === '🎤') {
                addActivityItem(icon, nickname, content);
            } else {
                // For low-priority items, just update counters without storing full details
                updateActivityCounters(type);
            }
        }
        
        // Performance mode toggle
        let performanceMode = false;
        function togglePerformanceMode() {
            performanceMode = !performanceMode;
            const perfBtn = document.getElementById('perfToggleBtn');
            
            if (performanceMode) {
                perfBtn.textContent = '🐌 Lightweight Mode';
                perfBtn.title = 'Switch to full activity feed mode';
                console.log('🚀 [PERFORMANCE] Enabled performance mode - lightweight activity tracking');
                
                // Clear old items and keep only recent important ones
                const now = new Date();
                const thirtyMinutesAgo = new Date(now.getTime() - 30 * 60 * 1000);
                activityItems = activityItems.filter(item => {
                    const itemTime = new Date(item.timestamp);
                    return itemTime > thirtyMinutesAgo && (
                        item.type === 'gift' || 
                        item.type === 'comment' || 
                        item.icon === '🤖' || 
                        item.icon === '🎤'
                    );
                });
            } else {
                perfBtn.textContent = '🚀 Performance Mode';
                perfBtn.title = 'Switch to lightweight mode for better performance';
                console.log('🐌 [PERFORMANCE] Disabled performance mode - full activity tracking');
            }
            
            // Update display
            updateActivityDisplay();
        }

        // Get activity type from icon
        function getActivityType(icon) {
            if (icon === '💬') return 'comment';
            if (icon === '❤️') return 'like';
            if (icon === '🎁') return 'gift';
            if (icon === '📤') return 'share';
            if (icon === '👥') return 'viewer';
            return 'other';
        }

        // Update activity display with smart filtering and pagination
        function updateActivityDisplay() {
            const activityFeed = document.getElementById('activityFeed');
            if (!activityFeed) return;
            
            // Filter by current tab with smart defaults
            const currentTab = getCurrentActivityTab();
            let filteredItems = activityItems;
            
            if (currentTab !== 'all') {
                filteredItems = activityItems.filter(item => {
                    if (currentTab === 'messages') return item.type === 'comment';
                    if (currentTab === 'engagements') return item.type === 'like' || item.type === 'gift' || item.type === 'share';
                    return true;
                });
            }
            
            // Smart filtering: Show only recent and important items by default
            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
            
            // Filter out old, low-priority items to reduce display load
            filteredItems = filteredItems.filter(item => {
                const itemTime = new Date(item.timestamp);
                const isRecent = itemTime > oneHourAgo;
                const isImportant = item.type === 'gift' || item.type === 'comment' || item.icon === '🤖' || item.icon === '🎤';
                
                // Keep recent items and important items, filter out old low-priority ones
                return isRecent || isImportant;
            });
            
            // Calculate pagination
            totalActivityPages = Math.ceil(filteredItems.length / maxActivityItems);
            if (currentActivityPage >= totalActivityPages) {
                currentActivityPage = Math.max(0, totalActivityPages - 1);
            }
            
            // Get items for current page
            const startIndex = currentActivityPage * maxActivityItems;
            const endIndex = startIndex + maxActivityItems;
            const pageItems = filteredItems.slice(startIndex, endIndex);
            
            // Clear and rebuild
            activityFeed.innerHTML = '';
            
            if (pageItems.length === 0) {
                activityFeed.innerHTML = '<div class="feed-item"><div class="feed-content">No activity to display...</div></div>';
                updateActivityPagination();
                return;
            }
            
            pageItems.forEach((item, index) => {
                const feedItem = document.createElement('div');
                feedItem.className = 'feed-item';
                
                const timeAgo = getTimeAgo(item.timestamp);
                const sentimentClass = item.sentiment !== null ? getSentimentClass(item.sentiment) : '';
                
                feedItem.innerHTML = `
                    <div class="feed-header-row">
                        <span class="feed-type-icon">${item.icon}</span>
                        <span class="feed-user">${item.nickname}</span>
                        <span class="feed-time">${timeAgo}</span>
                        ${item.sentiment !== null ? `<span class="feed-sentiment ${sentimentClass}">${getSentimentText(item.sentiment)}</span>` : ''}
                    </div>
                    <div class="feed-content">${item.content}</div>
                `;
                
                activityFeed.appendChild(feedItem);
            });
            
            // Update pagination controls
            updateActivityPagination();
        }

        // Get current activity tab
        function getCurrentActivityTab() {
            const activeTab = document.querySelector('.activity-tabs .tab-btn.active');
            return activeTab ? activeTab.getAttribute('onclick').match(/'([^']+)'/)[1] : 'all';
        }

        // Get sentiment class for styling
        function getSentimentClass(sentiment) {
            if (sentiment > 0.3) return 'positive';
            if (sentiment < -0.3) return 'negative';
            return 'neutral';
        }

        // Get sentiment text
        function getSentimentText(sentiment) {
            if (sentiment > 0.3) return '😊';
            if (sentiment < -0.3) return '😔';
            return '😐';
        }
        
        // Activity pagination functions
        function nextActivityPage() {
            if (currentActivityPage < totalActivityPages - 1) {
                currentActivityPage++;
                updateActivityDisplay();
            }
        }
        
        function previousActivityPage() {
            if (currentActivityPage > 0) {
                currentActivityPage--;
                updateActivityDisplay();
            }
        }
        
        function goToActivityPage(page) {
            if (page >= 0 && page < totalActivityPages) {
                currentActivityPage = page;
                updateActivityDisplay();
            }
        }
        
        function updateActivityPagination() {
            const paginationContainer = document.getElementById('activityPagination');
            if (!paginationContainer) return;
            
            if (totalActivityPages <= 1) {
                paginationContainer.innerHTML = '';
                return;
            }
            
            let paginationHTML = '';
            
            // Previous button
            paginationHTML += `<button class="pagination-btn" onclick="previousActivityPage()" ${currentActivityPage === 0 ? 'disabled' : ''}>◀</button>`;
            
            // Page numbers
            for (let i = 0; i < totalActivityPages; i++) {
                if (i === currentActivityPage) {
                    paginationHTML += `<span class="pagination-current">${i + 1}</span>`;
                } else {
                    paginationHTML += `<button class="pagination-btn" onclick="goToActivityPage(${i})">${i + 1}</button>`;
                }
            }
            
            // Next button
            paginationHTML += `<button class="pagination-btn" onclick="nextActivityPage()" ${currentActivityPage === totalActivityPages - 1 ? 'disabled' : ''}>▶</button>`;
            
            paginationContainer.innerHTML = paginationHTML;
        }

        // Activity control functions
        function updateMaxItems() {
            const select = document.getElementById('maxItems');
            maxActivityItems = parseInt(select.value);
            
            // Update display with new page size
            updateActivityDisplay();
        }



        function toggleActivityPause() {
            activityPaused = !activityPaused;
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (activityPaused) {
                pauseBtn.textContent = '▶️ Resume';
                pauseBtn.classList.add('paused');
            } else {
                pauseBtn.textContent = '⏸️ Pause';
                pauseBtn.classList.remove('paused');
            }
        }





        // Update entertainment breakdown
        function updateEntertainmentBreakdown(entertainmentMetrics) {
            if (!entertainmentMetrics) return;
            
            const engagementEl = document.getElementById('engagementIntensity');
            const contentEl = document.getElementById('contentReception');
            const energyEl = document.getElementById('audienceEnergy');
            const retentionEl = document.getElementById('retentionQuality');
            
            if (engagementEl) engagementEl.textContent = `${Math.round((entertainmentMetrics.engagementIntensity || 0) * 100)}%`;
            if (contentEl) contentEl.textContent = `${Math.round((entertainmentMetrics.contentReception || 0) * 100)}%`;
            if (energyEl) energyEl.textContent = `${Math.round((entertainmentMetrics.audienceEnergy || 0) * 100)}%`;
            if (retentionEl) retentionEl.textContent = `${Math.round((entertainmentMetrics.retentionQuality || 0) * 100)}%`;
        }
        
                // Update top engaged users display with enhanced engagement data
        function updateTopEngagedUsers(engagementData) {
            const topUsersElement = document.getElementById('topEngagedUsers');
            if (!topUsersElement) return;
            
            // Prevent unnecessary updates with empty data
            if (!engagementData && (!window.currentMetrics || !window.currentMetrics.viewerStats)) {
                console.log('⏭️ [TOP ENGAGED] Skipping update - no data available');
                return;
            }
            
            console.log('🔄 [TOP ENGAGED] Updating with data:', engagementData);
            
            // Validate engagement data structure
            if (Array.isArray(engagementData)) {
                console.log('🔍 [TOP ENGAGED] Data validation:');
                engagementData.slice(0, 3).forEach((viewer, index) => {
                    console.log(`  Viewer ${index}:`, {
                        userId: viewer.userId,
                        nickname: viewer.nickname,
                        totalLikes: viewer.totalLikes,
                        totalGifts: viewer.totalGifts,
                        totalComments: viewer.totalComments,
                        totalShares: viewer.totalShares,
                        totalDiamonds: viewer.totalDiamonds,
                        watchTime: viewer.watchTime,
                        engagementScore: viewer.engagementScore,
                        isFollower: viewer.isFollower,
                        followTime: viewer.followTime
                    });
                });
            }
            
            // Check if we received engagement ranking data directly
            if (Array.isArray(engagementData) && engagementData.length > 0) {
                console.log('✅ [TOP ENGAGED] Using direct engagement data, count:', engagementData.length);
                
                // Remove duplicates by userId and sort by engagement score
                const uniqueViewers = engagementData.reduce((acc, viewer) => {
                    if (!acc.find(v => v.userId === viewer.userId)) {
                        acc.push(viewer);
                    }
                    return acc;
                }, []);
                
                // Sort by engagement score (highest first)
                uniqueViewers.sort((a, b) => (b.engagementScore || 0) - (a.engagementScore || 0));
                
                console.log('🔍 [TOP ENGAGED] Unique viewers after deduplication:', uniqueViewers.length);
                console.log('🏆 [TOP ENGAGED] Top 5 scores:', uniqueViewers.slice(0, 5).map(v => `${v.nickname}: ${v.engagementScore}`));
                
                topUsersElement.innerHTML = '';
                uniqueViewers.slice(0, 5).forEach((viewer, index) => {
                    const userItem = document.createElement('div');
                    userItem.className = 'feed-item';
                    
                    const watchTimeFormatted = formatWatchTime(viewer.watchTime || 0);
                    const followerBadge = viewer.isFollower ? '👑' : '';
                    const engagementScore = Math.round(viewer.engagementScore || 0);
                    
                    // Debug log for each viewer
                    console.log(`👤 [TOP ENGAGED] ${index + 1}. ${viewer.nickname}: Score=${engagementScore}, Likes=${viewer.totalLikes}, Gifts=${viewer.totalGifts}, Watch=${watchTimeFormatted}`);
                    
                    userItem.innerHTML = `
                        <div class="feed-user">🏆 ${index + 1}. ${viewer.nickname} ${followerBadge}</div>
                        <div class="feed-content">
                            <div>❤️ Likes: ${viewer.totalLikes || 0} | 🎁 Gifts: ${viewer.totalGifts || 0}</div>
                            <div>💎 Diamonds: ${viewer.totalDiamonds || 0} | ⏱️ Watch: ${watchTimeFormatted}</div>
                            <div>📊 Score: ${engagementScore}</div>
                        </div>
                        <div class="feed-time">${viewer.followTime ? '👑 ' + new Date(viewer.followTime).toLocaleTimeString() : '⏱️ ' + watchTimeFormatted}</div>
                    `;
                    topUsersElement.appendChild(userItem);
                });
                return;
            }
            
            // Fallback: Check if we have viewer stats in current metrics
            if (window.currentMetrics && window.currentMetrics.viewerStats && window.currentMetrics.viewerStats.engagementRanking) {
                const engagementRanking = window.currentMetrics.viewerStats.engagementRanking;
                if (engagementRanking.length > 0) {
                    console.log('✅ [TOP ENGAGED] Using current metrics engagement data, count:', engagementRanking.length);
                    
                    // Remove duplicates by userId and sort by engagement score
                    const uniqueViewers = engagementRanking.reduce((acc, viewer) => {
                        if (!acc.find(v => v.userId === viewer.userId)) {
                            acc.push(viewer);
                        }
                        return acc;
                    }, []);
                    
                    // Sort by engagement score (highest first)
                    uniqueViewers.sort((a, b) => (b.engagementScore || 0) - (a.engagementScore || 0));
                    
                    console.log('🔍 [TOP ENGAGED] Unique viewers after deduplication:', uniqueViewers.length);
                    console.log('🏆 [TOP ENGAGED] Top 5 scores:', uniqueViewers.slice(0, 5).map(v => `${v.nickname}: ${v.engagementScore}`));
                    
                    topUsersElement.innerHTML = '';
                    uniqueViewers.slice(0, 5).forEach((viewer, index) => {
                        const userItem = document.createElement('div');
                        userItem.className = 'feed-item';
                        
                        const watchTimeFormatted = formatWatchTime(viewer.watchTime || 0);
                        const followerBadge = viewer.isFollower ? '👑' : '';
                        const engagementScore = Math.round(viewer.engagementScore || 0);
                        
                        // Debug log for each viewer
                        console.log(`👤 [TOP ENGAGED] ${index + 1}. ${viewer.nickname}: Score=${engagementScore}, Likes=${viewer.totalLikes}, Gifts=${viewer.totalGifts}, Watch=${watchTimeFormatted}`);
                        
                        userItem.innerHTML = `
                            <div class="feed-user">🏆 ${index + 1}. ${viewer.nickname} ${followerBadge}</div>
                            <div class="feed-content">
                                <div>❤️ Likes: ${viewer.totalLikes || 0} | 🎁 Gifts: ${viewer.totalGifts || 0}</div>
                                <div>💎 Diamonds: ${viewer.totalDiamonds || 0} | ⏱️ Watch: ${watchTimeFormatted}</div>
                                <div>📊 Score: ${engagementScore}</div>
                            </div>
                            <div class="feed-time">${viewer.followTime ? '👑 ' + new Date(viewer.followTime).toLocaleTimeString() : '⏱️ ' + watchTimeFormatted}</div>
                        `;
                        topUsersElement.appendChild(userItem);
                    });
                    return;
                }
            }
            
            // Only show waiting message if we truly have no data
            if (!window.currentMetrics || !window.currentMetrics.viewerStats) {
                console.log('⏳ [TOP ENGAGED] No metrics data yet, showing waiting message');
                topUsersElement.innerHTML = '<div class="feed-item">Waiting for engagement data...</div>';
            } else {
                console.log('⚠️ [TOP ENGAGED] Has metrics but no engagement ranking, showing empty state');
                topUsersElement.innerHTML = '<div class="feed-item">No viewers with engagement actions yet. Encourage viewers to like, comment, or send gifts!</div>';
            }
        }

        // Update new followers display (for individual follower events)
        function updateNewFollowers(followData) {
            const newFollowersElement = document.getElementById('newFollowers');
            if (!newFollowersElement) return;
            
            // Check if this follower already exists in the display
            const existingItems = newFollowersElement.querySelectorAll('.feed-item');
            const alreadyExists = Array.from(existingItems).some(item => {
                const followerId = item.getAttribute('data-follower-id');
                return followerId === (followData.userId || followData.nickname);
            });
            
            if (alreadyExists) {
                console.log(`🔄 [FOLLOWERS] ${followData.nickname} (ID: ${followData.userId || followData.nickname}) already displayed - skipping duplicate`);
                return;
            }
            
            // Add to the top of the list
            const followItem = document.createElement('div');
            followItem.className = 'feed-item';
            followItem.setAttribute('data-follower-id', followData.userId || followData.nickname);
            followItem.innerHTML = `
                <div class="feed-user">🆕 ${followData.nickname}</div>
                <div class="feed-content">Started following!</div>
                <div class="feed-time">${new Date(followData.timestamp).toLocaleTimeString()}</div>
            `;
            
            // Insert at the top
            if (newFollowersElement.firstChild) {
                newFollowersElement.insertBefore(followItem, newFollowersElement.firstChild);
            } else {
                newFollowersElement.appendChild(followItem);
            }
            
            // Limit to 10 followers
            const items = newFollowersElement.querySelectorAll('.feed-item');
            if (items.length > 10) {
                items[items.length - 1].remove();
            }
        }

        // Update new followers list (for bulk updates - replaces entire list)
        function updateNewFollowersList(followersArray) {
            const newFollowersElement = document.getElementById('newFollowers');
            if (!newFollowersElement) return;
            
            // Clear existing followers
            newFollowersElement.innerHTML = '';
            
            // Add each follower (limit to 10)
            const followersToShow = followersArray.slice(0, 10);
            followersToShow.forEach(follower => {
                const followItem = document.createElement('div');
                followItem.className = 'feed-item';
                followItem.setAttribute('data-follower-id', follower.userId || follower.nickname);
                followItem.innerHTML = `
                    <div class="feed-user">🆕 ${follower.nickname}</div>
                    <div class="feed-content">Started following!</div>
                    <div class="feed-time">${new Date(follower.timestamp).toLocaleTimeString()}</div>
                `;
                newFollowersElement.appendChild(followItem);
            });
            
            console.log(`🔄 [FOLLOWERS] Updated followers list with ${followersToShow.length} followers`);
        }

        // Gift Alert Functions with Queue System
        let giftQueue = [];
        let isShowingGift = false;
        let giftDisplayTimer = null;
        let maxGiftQueueSize = 10; // Maximum gifts to queue
        let giftDisplayDuration = 3000; // 3 seconds per gift
        let autoCloseDelay = 8000; // 8 seconds before auto-close

        function showGiftAlert(giftData) {
            // Check if we're in connecting state - don't show gifts during connection
            const streamStatus = document.getElementById('streamStatus');
            if (streamStatus && streamStatus.textContent.includes('Connecting')) {
                console.log('🎁 [GIFT ALERT] Skipping gift during connection:', giftData.nickname);
                return;
            }
            
            console.log('🎁 [GIFT ALERT] Received gift:', giftData.nickname, giftData.gift?.name);
            
            // Add gift to queue
            addGiftToQueue(giftData);
            
            // Start processing if not already showing
            if (!isShowingGift) {
                processGiftQueue();
            }
        }
        
        function addGiftToQueue(giftData) {
            // Check if sender already has gifts in queue
            const existingGiftIndex = giftQueue.findIndex(g => g.nickname === giftData.nickname);
            
            if (existingGiftIndex !== -1) {
                // Merge with existing gift from same sender
                const existingGift = giftQueue[existingGiftIndex];
                existingGift.giftCount = (existingGift.giftCount || 1) + 1;
                existingGift.totalDiamonds = (existingGift.totalDiamonds || 0) + (giftData.diamondCount || 0);
                existingGift.totalValue = (existingGift.totalValue || 0) + (giftData.usdValue || 0);
                existingGift.timestamp = Date.now(); // Update timestamp
                console.log(`🎁 [GIFT ALERT] Merged gift from ${giftData.nickname}, total: ${existingGift.giftCount}`);
            } else {
                // Add new gift to queue
                const queuedGift = {
                    ...giftData,
                    giftCount: 1,
                    totalDiamonds: giftData.diamondCount || 0,
                    totalValue: giftData.usdValue || 0,
                    timestamp: Date.now()
                };
                
                giftQueue.push(queuedGift);
                console.log(`🎁 [GIFT ALERT] Added new gift to queue from ${giftData.nickname}`);
            }
            
            // Limit queue size to prevent memory issues
            if (giftQueue.length > maxGiftQueueSize) {
                const removedGift = giftQueue.shift();
                console.log(`🎁 [GIFT ALERT] Queue full, removed oldest gift from ${removedGift.nickname}`);
                
                // Update the gift management panel count after removing gift
                updateGiftManagementPanel();
            }
            
            // Update the gift management panel count
            updateGiftManagementPanel();
        }

                // New non-blocking gift notification system
        let giftNotificationsPaused = false;
        let maxVisibleNotifications = 3; // Maximum notifications visible at once
        
        function processGiftQueue() {
            if (giftQueue.length === 0 || giftNotificationsPaused) {
                return;
            }
            
            // Check if we're in connecting state - don't process gifts during connection
            const streamStatus = document.getElementById('streamStatus');
            if (streamStatus && streamStatus.textContent.includes('Connecting')) {
                console.log('🎁 [GIFT ALERT] Skipping gift processing during connection');
                return;
            }
            
            // Process gifts in batches for better performance
            const giftsToProcess = Math.min(3, giftQueue.length);
            for (let i = 0; i < giftsToProcess; i++) {
                const giftData = giftQueue.shift();
                if (giftData) {
                    displayGiftNotification(giftData);
                }
            }
            
            // Update the gift management panel
            updateGiftManagementPanel();
            
            // Continue processing if there are more gifts
            if (giftQueue.length > 0) {
                setTimeout(() => {
                    processGiftQueue();
                }, 1000); // 1 second delay between batches
            }
        }
        
        function displayGiftNotification(giftData) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'gift-notification';
            notification.id = `gift-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            // Set notification content
            notification.innerHTML = `
                <div class="gift-notification-header">
                    <span class="gift-notification-icon">🎁</span>
                    <span class="gift-notification-title">Gift Received!</span>
                </div>
                <div class="gift-notification-sender">
                    <img class="gift-sender-avatar" src="${giftData.profilePic || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMzAiIGN5PSIzMCIgcj0iMzAiIGZpbGw9IiM2NjY2NjYiLz4KPHN2ZyB4PSIxNSIgeT0iMTUiIHdpZHRoPSIzMCIgaGVpZ2h0PSIzMCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJ3aGl0ZSI+CjxwYXRoIGQ9Ik0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyeiIgZmlsbD0iIzY2NjY2NiIvPgo8L3N2Zz4KPC9zdmc+'}" alt="Profile Picture">
                    <span class="gift-sender-name">${giftData.nickname}${giftData.giftCount > 1 ? ` (${giftData.giftCount} gifts)` : ''}</span>
                </div>
                <div class="gift-notification-details">
                    <div class="gift-name">${giftData.gift?.name || 'Unknown Gift'}</div>
                    <div class="gift-value">${giftData.totalDiamonds || 0} 💎</div>
                </div>
                <div class="gift-notification-actions">
                    <button class="gift-action-mini" onclick="generateShoutout('${giftData.nickname}')" title="Generate shoutout">🎤</button>
                    <button class="gift-action-mini" onclick="generateThankYou('${giftData.nickname}')" title="Generate thank you">🙏</button>
                    <button class="gift-action-mini" onclick="removeGiftNotification('${notification.id}')" title="Dismiss">✕</button>
                </div>
            `;
            
            // Add to notifications container
            const container = document.getElementById('giftNotificationsContainer');
            if (container) {
                container.appendChild(notification);
                
                // Limit visible notifications
                const notifications = container.querySelectorAll('.gift-notification');
                if (notifications.length > maxVisibleNotifications) {
                    // Remove oldest notification
                    const oldestNotification = notifications[0];
                    oldestNotification.classList.add('slide-out');
                    setTimeout(() => {
                        if (oldestNotification.parentNode) {
                            oldestNotification.parentNode.removeChild(oldestNotification);
                        }
                    }, 300);
                }
                
                // Auto-remove notification after 8 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.classList.add('slide-out');
                        setTimeout(() => {
                            if (notification.parentNode) {
                                notification.parentNode.removeChild(notification);
                            }
                        }, 300);
                    }
                }, 8000);
            }
        }
        
        function removeGiftNotification(notificationId) {
            const notification = document.getElementById(notificationId);
            if (notification) {
                notification.classList.add('slide-out');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }
        }
        
        function updateGiftManagementPanel() {
            const indicatorCount = document.getElementById('giftIndicatorCount');
            
            if (indicatorCount) {
                indicatorCount.textContent = giftQueue.length;
                console.log(`🎁 [GIFT PANEL] Updated count to: ${giftQueue.length}`);
            } else {
                console.warn('⚠️ [GIFT PANEL] Could not find giftIndicatorCount element');
            }
        }
        

        
        function pauseGiftNotifications() {
            giftNotificationsPaused = true;
            document.getElementById('pauseGiftBtn').style.display = 'none';
            document.getElementById('resumeGiftBtn').style.display = 'inline-block';
            console.log('⏸️ [GIFT ALERT] Gift notifications paused');
        }
        
        function resumeGiftNotifications() {
            giftNotificationsPaused = false;
            document.getElementById('resumeGiftBtn').style.display = 'none';
            document.getElementById('pauseGiftBtn').style.display = 'inline-block';
            console.log('▶️ [GIFT ALERT] Gift notifications resumed');
            // Process any pending gifts
            if (giftQueue.length > 0) {
                processGiftQueue();
            }
        }
        
        // Emergency gift queue clear function
        function clearGiftQueue() {
            console.log('🚨 [GIFT ALERT] Emergency clearing gift queue');
            giftQueue = [];
            
            // Clear all visible notifications
            const container = document.getElementById('giftNotificationsContainer');
            if (container) {
                container.innerHTML = '';
            }
            
            // Update the management panel
            updateGiftManagementPanel();
            
            // Add activity item to show gift queue was cleared
            addActivityItem('🚨', 'System', 'Gift queue cleared - all pending gifts removed');
        }
        
        // Gift queue status function
        function getGiftQueueStatus() {
            return {
                queueLength: giftQueue.length,
                isPaused: giftNotificationsPaused
            };
        }

        function generateGiftPrompt(giftData, giftCount = 1) {
            const { nickname, gift, diamondCount } = giftData;
            const giftName = gift?.name || 'amazing gift';
            const isHighValue = diamondCount > 100;
            const isMediumValue = diamondCount > 50;
            
            let prompt = '';
            
            if (giftCount > 1) {
                // Multiple gifts from same user
                if (isHighValue) {
                    prompt = `Incredible! ${nickname} has sent ${giftCount} gifts including ${giftName} (${diamondCount} diamonds total)! This is amazing support! Give them a special shoutout and consider making them a VIP or moderator.`;
                } else if (isMediumValue) {
                    prompt = `${nickname} is on fire with ${giftCount} gifts including ${giftName}! Show them extra love and maybe ask about their favorite content to keep them engaged.`;
                } else {
                    prompt = `${nickname} has sent ${giftCount} gifts! They're clearly loving the stream. Thank them warmly and maybe give them a special mention.`;
                }
            } else {
                // Single gift
                if (isHighValue) {
                    prompt = `Wow! ${nickname} just sent ${giftName} worth ${diamondCount} diamonds! This is incredible support! Consider giving them a special shoutout and maybe ask about their day or interests to build connection.`;
                } else if (isMediumValue) {
                    prompt = `${nickname} sent ${giftName} (${diamondCount} diamonds)! Great engagement! Acknowledge them warmly and maybe ask a question to keep them engaged.`;
                } else {
                    prompt = `${nickname} sent ${giftName}! Every gift matters. Thank them sincerely and encourage continued engagement.`;
                }
            }
            
            return prompt;
        }

        function generateShoutout() {
            console.log('🎤 [SHOUTOUT] Button clicked - starting shoutout generation');
            
            // Get current gift data from the displayed gift alert
            const senderName = document.getElementById('giftSenderName');
            const giftName = document.getElementById('giftName');
            const giftCounterBadge = document.getElementById('giftCounterBadge');
            
            console.log('🎤 [SHOUTOUT] Elements found:', { senderName, giftName, giftCounterBadge });
            
            if (!senderName || !giftName) {
                console.warn('⚠️ [SHOUTOUT] Gift data not available');
                return;
            }
            
            const nickname = senderName.textContent.split(' (')[0]; // Remove gift count if present
            const giftNameText = giftName.textContent;
            const giftCount = giftCounterBadge && giftCounterBadge.style.display !== 'none' ? 
                parseInt(giftCounterBadge.textContent) : 1;
            
            console.log('🎤 [SHOUTOUT] Generating shoutout for:', nickname, giftNameText, giftCount);
            
            // Generate shoutout message based on gift count
            let shoutoutMessages;
            if (giftCount > 1) {
                shoutoutMessages = [
                    `🔥 SHOUTOUT to ${nickname} for ${giftCount} AMAZING gifts including ${giftNameText}! You're absolutely legendary! 🔥`,
                    `🎉 ${nickname} just dropped ${giftCount} gifts including ${giftNameText}! You're the real MVP! 🎉`,
                    `💫 ${nickname} with ${giftCount} gifts including ${giftNameText}! You're making this stream incredible! 💫`,
                    `🌟 ${nickname} thank you for ${giftCount} gifts including ${giftNameText}! You're absolutely amazing! 🌟`,
                    `🚀 ${nickname} just sent ${giftCount} gifts including ${giftNameText}! You're taking this stream to the next level! 🚀`
                ];
            } else {
                shoutoutMessages = [
                    `🔥 SHOUTOUT to ${nickname} for the ${giftNameText}! You're absolutely amazing! 🔥`,
                    `🎉 ${nickname} just dropped ${giftNameText}! You're the real MVP! 🎉`,
                    `💫 ${nickname} with the ${giftNameText}! You're making this stream incredible! 💫`,
                    `🌟 ${nickname} thank you for the ${giftNameText}! You're absolutely legendary! 🌟`,
                    `🚀 ${nickname} just sent ${giftNameText}! You're taking this stream to the next level! 🚀`
                ];
            }
            
            const randomMessage = shoutoutMessages[Math.floor(Math.random() * shoutoutMessages.length)];
            
            // Add to activity feed
            addActivityItem('🎤', 'AI Assistant', `Generated shoutout: "${randomMessage}"`);
            
            // Speak the shoutout using TTS if enabled
            if (ttsEnabled) {
                speakText(randomMessage, 'high');
            }
            
            // Close the alert
            closeGiftAlert();
            
            // You could also send this to a text-to-speech system or copy to clipboard
            console.log('Generated shoutout:', randomMessage);
        }

        function generateThankYou() {
            console.log('🙏 [THANK YOU] Button clicked - starting thank you generation');
            
            // Get current gift data from the displayed gift alert
            const senderName = document.getElementById('giftSenderName');
            const giftName = document.getElementById('giftName');
            const giftCounterBadge = document.getElementById('giftCounterBadge');
            
            console.log('🙏 [THANK YOU] Elements found:', { senderName, giftName, giftCounterBadge });
            
            if (!senderName || !giftName) {
                console.warn('⚠️ [THANK YOU] Gift data not available');
                return;
            }
            
            const nickname = senderName.textContent.split(' (')[0]; // Remove gift count if present
            const giftNameText = giftName.textContent;
            const giftCount = giftCounterBadge && giftCounterBadge.style.display !== 'none' ? 
                parseInt(giftCounterBadge.textContent) : 1;
            
            console.log('🙏 [THANK YOU] Generating thank you for:', nickname, giftNameText, giftCount);
            
            // Generate thank you message based on gift count
            let thankYouMessages;
            if (giftCount > 1) {
                thankYouMessages = [
                    `🙏 Thank you so much ${nickname} for ${giftCount} amazing gifts including ${giftNameText}! You're absolutely incredible! 🙏`,
                    `💝 ${nickname}, I'm so grateful for ${giftCount} gifts including ${giftNameText}! You're the best! 💝`,
                    `🥰 ${nickname} thank you for ${giftCount} gifts including ${giftNameText}! You're making my day! 🥰`,
                    `✨ ${nickname} you're amazing! Thank you for ${giftCount} gifts including ${giftNameText}! ✨`,
                    `💖 ${nickname} I can't thank you enough for ${giftCount} gifts including ${giftNameText}! You're wonderful! 💖`
                ];
            } else {
                thankYouMessages = [
                    `🙏 Thank you so much ${nickname} for the ${giftNameText}! You're incredible! 🙏`,
                    `💝 ${nickname}, I'm so grateful for the ${giftNameText}! You're the best! 💝`,
                    `🥰 ${nickname} thank you for the ${giftNameText}! You're making my day! 🥰`,
                    `✨ ${nickname} you're amazing! Thank you for the ${giftNameText}! ✨`,
                    `💖 ${nickname} I can't thank you enough for the ${giftNameText}! You're wonderful! 💖`
                ];
            }
            
            const randomMessage = thankYouMessages[Math.floor(Math.random() * thankYouMessages.length)];
            
            // Add to activity feed
            addActivityItem('🙏', 'AI Assistant', `Generated thank you: "${randomMessage}"`);
            
            // Speak the thank you using TTS if enabled
            if (ttsEnabled) {
                speakText(randomMessage, 'high');
            }
            
            // Close the alert
            closeGiftAlert();
            
            // You could also send this to a text-to-speech system or copy to clipboard
            console.log('Generated thank you:', randomMessage);
        }

        // AI Welcome System Functions
        function showAIWelcome(welcomeData) {
            const { viewer, welcomeMessage, engagementTips, viewerCount } = welcomeData;
            
            // Add welcome message to activity feed
            addActivityItem('🤖', 'AI Assistant', `Welcome: ${welcomeMessage}`);
            
            // Add engagement tips to activity feed
            engagementTips.forEach(tip => {
                addActivityItem('💡', 'AI Tips', tip);
            });
            
            // Show welcome notification
            showWelcomeNotification(viewer, welcomeMessage, engagementTips, viewerCount);
        }

        function showWelcomeNotification(viewer, welcomeMessage, engagementTips, viewerCount) {
            // Add welcome message to activity feed
            addActivityItem('👋', 'New Viewer', `Welcome ${viewer.nickname}!`);
            
            // Add engagement tips to activity feed
            engagementTips.forEach(tip => {
                addActivityItem('💡', 'AI Tips', tip);
            });
            
            // Show non-blocking viewer notification
            displayViewerNotification(viewer);
            
            // Update viewer counter
            updateViewerCounter();
        }
        
        // Non-blocking viewer notification system
        let viewerNotificationsPaused = false;
        let maxVisibleViewerNotifications = 3;
        let viewerNotificationQueue = [];
        
        function displayViewerNotification(viewer) {
            // Check if viewer notifications are paused
            if (viewerNotificationsPaused) {
                console.log('⏸️ [VIEWER] Skipping viewer notification - paused');
                return;
            }
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'viewer-notification';
            notification.id = `viewer-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            // Set notification content
            notification.innerHTML = `
                <div class="viewer-notification-header">
                    <span class="viewer-notification-icon">👋</span>
                    <span class="viewer-notification-title">New Viewer!</span>
                </div>
                <div class="viewer-notification-sender">
                    <img class="viewer-sender-avatar" src="${viewer.profilePic || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjAiIGN5PSIyMCIgcj0iMjAiIGZpbGw9IiM2NjY2NjYiLz4KPHN2ZyB4PSIxMCIgeT0iMTAiIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJ3aGl0ZSI+CjxwYXRoIGQ9Ik0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyeiIgZmlsbD0iIzY2NjY2NiIvPgo8L3N2Zz4KPC9zdmc+'}" alt="Profile Picture">
                    <span class="viewer-sender-name">${viewer.nickname}</span>
                </div>
                <div class="viewer-notification-actions">
                    <button class="viewer-action-mini" onclick="speakWelcome('${viewer.nickname}')" title="Speak welcome">🔊</button>
                    <button class="viewer-action-mini" onclick="removeViewerNotification('${notification.id}')" title="Dismiss">✕</button>
                </div>
            `;
            
            // Add to notifications container
            const container = document.getElementById('viewerNotificationsContainer');
            if (container) {
                container.appendChild(notification);
                
                // Limit visible notifications
                const notifications = container.querySelectorAll('.viewer-notification');
                if (notifications.length > maxVisibleViewerNotifications) {
                    // Remove oldest notification
                    const oldestNotification = notifications[0];
                    oldestNotification.classList.add('slide-out');
                    setTimeout(() => {
                        if (oldestNotification.parentNode) {
                            oldestNotification.parentNode.removeChild(oldestNotification);
                        }
                    }, 300);
                }
                
                // Auto-remove notification after 6 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.classList.add('slide-out');
                        setTimeout(() => {
                            if (notification.parentNode) {
                                notification.parentNode.removeChild(notification);
                            }
                        }, 300);
                    }
                }, 6000);
            }
        }
        
        function removeViewerNotification(notificationId) {
            const notification = document.getElementById(notificationId);
            if (notification) {
                notification.classList.add('slide-out');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }
        }
        
        function updateViewerCounter() {
            const viewerCountElement = document.getElementById('viewerIndicatorCount');
            if (viewerCountElement) {
                // Get count from activity feed (new viewers)
                const viewerItems = document.querySelectorAll('.activity-item:has(.activity-icon:contains("👋"))');
                viewerCountElement.textContent = viewerItems.length;
            }
        }
        
        function clearViewerHistory() {
            console.log('🗑️ [VIEWER] Clearing viewer history');
            
            // Clear all visible viewer notifications
            const container = document.getElementById('viewerNotificationsContainer');
            if (container) {
                container.innerHTML = '';
            }
            
            // Reset viewer counter
            updateViewerCounter();
            
            // Add activity item to show viewer history was cleared
            addActivityItem('🗑️', 'System', 'Viewer history cleared - all notifications removed');
        }
        
        function pauseViewerNotifications() {
            viewerNotificationsPaused = true;
            document.getElementById('pauseViewerBtn').style.display = 'none';
            document.getElementById('resumeViewerBtn').style.display = 'inline-block';
            console.log('⏸️ [VIEWER] Viewer notifications paused');
        }
        
        function resumeViewerNotifications() {
            viewerNotificationsPaused = false;
            document.getElementById('resumeViewerBtn').style.display = 'none';
            document.getElementById('pauseViewerBtn').style.display = 'inline-block';
            console.log('▶️ [VIEWER] Viewer notifications resumed');
        }
        
        // Update AI insights display
        function updateAIInsights(data) {
            const aiInsightsElement = document.getElementById('aiInsights');
            if (!aiInsightsElement) return;
            
            if (!data.keywordFrequency || Object.keys(data.keywordFrequency).length === 0) {
                aiInsightsElement.innerHTML = '<div class="feed-item">Waiting for AI analysis...</div>';
                return;
            }
            
            // Get top keywords
            const topKeywords = Object.entries(data.keywordFrequency)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5); // Top 5 keywords
            
            if (topKeywords.length === 0) {
                aiInsightsElement.innerHTML = '<div class="feed-item">No keyword data yet...</div>';
                return;
            }
            
            aiInsightsElement.innerHTML = '';
            
            // Add sentiment insight
            if (data.rollingSentimentScore !== undefined) {
                const sentimentItem = document.createElement('div');
                sentimentItem.className = 'feed-item';
                const sentimentIcon = data.rollingSentimentScore > 0.5 ? '😊' : data.rollingSentimentScore < -0.5 ? '😞' : '😐';
                sentimentItem.innerHTML = `
                    <div class="feed-user">📊 Sentiment Analysis</div>
                    <div class="feed-content">${sentimentIcon} Rolling Score: ${data.rollingSentimentScore.toFixed(2)}</div>
                    <div class="feed-time">${new Date().toLocaleTimeString()}</div>
                `;
                aiInsightsElement.appendChild(sentimentItem);
            }
            
            // Add top keywords
            topKeywords.forEach(([keyword, count]) => {
                const keywordItem = document.createElement('div');
                keywordItem.className = 'feed-item';
                keywordItem.innerHTML = `
                    <div class="feed-user">🔑 Trending Keyword</div>
                    <div class="feed-content">"${keyword}" (${count} mentions)</div>
                    <div class="feed-time">${new Date().toLocaleTimeString()}</div>
                `;
                aiInsightsElement.appendChild(keywordItem);
            });
        }

        // Show Wizard prompt (disabled - prompts moved to activity feed only)
        function showPrompt(promptData) {
            // Just add to activity feed since prompt panel was removed
            addActivityItem('🎭', 'Wizard', promptData.prompt);
        }
        
        // Show automated prompt (disabled - prompts moved to activity feed only)
        function showAutomatedPrompt(promptData) {
            // Just add to activity feed since prompt panel was removed
            addActivityItem('🤖', 'AI System', promptData.message);
        }

        // Add activity item to feed
        // Activity tab management
        let currentActivityTab = 'all';
        let allActivities = [];
        let messageActivities = [];
        let engagementActivities = [];

        function switchActivityTab(tab) {
            currentActivityTab = tab;
            
            // Update tab button states
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Filter and display activities
            displayFilteredActivities();
        }

        function displayFilteredActivities() {
            const feed = document.getElementById('activityFeed');
            feed.innerHTML = '';
            
            let activitiesToShow = [];
            switch (currentActivityTab) {
                case 'messages':
                    activitiesToShow = messageActivities;
                    break;
                case 'engagements':
                    activitiesToShow = engagementActivities;
                    break;
                default:
                    activitiesToShow = allActivities;
            }
            
            activitiesToShow.forEach(activity => {
                feed.appendChild(activity.element);
            });
        }

        // Legacy function removed - now handled by the smart activity management system above
        
        // Update top engagers display
        function updateTopEngagers(userLikeCounts) {
            const topEngagersDiv = document.getElementById('topEngagers');
            
            if (!userLikeCounts || Object.keys(userLikeCounts).length === 0) {
                topEngagersDiv.innerHTML = '<div class="feed-item">Waiting for like data...</div>';
                return;
            }
            
            // Convert to array and sort by total likes
            const sortedUsers = Object.entries(userLikeCounts)
                .map(([userId, userData]) => ({
                    userId,
                    nickname: userData.nickname,
                    totalLikes: userData.totalLikes,
                    lastLikeTime: userData.lastLikeTime
                }))
                .sort((a, b) => b.totalLikes - a.totalLikes)
                .slice(0, 10); // Show top 10
            
            // Clear existing content
            topEngagersDiv.innerHTML = '';
            
            // Add each top user
            sortedUsers.forEach((user, index) => {
                const item = document.createElement('div');
                item.className = 'feed-item';
                
                const rank = index + 1;
                const rankIcon = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `#${rank}`;
                const lastLikeTime = user.lastLikeTime ? new Date(user.lastLikeTime).toLocaleTimeString() : 'Unknown';
                
                item.innerHTML = `
                    <div class="feed-user">${rankIcon} ${user.nickname}</div>
                    <div class="feed-content">${user.totalLikes} likes</div>
                    <div class="feed-time">Last: ${lastLikeTime}</div>
                `;
                
                topEngagersDiv.appendChild(item);
            });
        }
        
        // Update AI insights display
        function updateAIInsights(metrics) {
            const aiInsightsDiv = document.getElementById('aiInsights');
            
            if (!metrics) {
                aiInsightsDiv.innerHTML = '<div class="feed-item">Waiting for AI analysis...</div>';
                return;
            }
            
            const insights = [];
            
            // Sentiment analysis
            if (metrics.rollingSentimentScore !== undefined) {
                const sentiment = metrics.rollingSentimentScore;
                let sentimentStatus = 'Neutral';
                let sentimentIcon = '😐';
                
                if (sentiment > 0.5) {
                    sentimentStatus = 'Positive';
                    sentimentIcon = '😊';
                } else if (sentiment < -0.5) {
                    sentimentStatus = 'Negative';
                    sentimentIcon = '😔';
                }
                
                insights.push({
                    icon: sentimentIcon,
                    title: 'Chat Sentiment',
                    content: `${sentimentStatus} (${sentiment.toFixed(2)})`,
                    color: sentiment > 0 ? '#4CAF50' : sentiment < 0 ? '#f44336' : '#FF9800'
                });
            }
            
            // Engagement trends
            if (metrics.commentsPerMinute !== undefined) {
                let engagementStatus = 'Normal';
                let engagementIcon = '📊';
                
                if (metrics.commentsPerMinute > 20) {
                    engagementStatus = 'High';
                    engagementIcon = '🔥';
                } else if (metrics.commentsPerMinute < 5) {
                    engagementStatus = 'Low';
                    engagementIcon = '📉';
                }
                
                insights.push({
                    icon: engagementIcon,
                    title: 'Comment Volume',
                    content: `${engagementStatus} (${metrics.commentsPerMinute}/min)`,
                    color: metrics.commentsPerMinute > 20 ? '#4CAF50' : metrics.commentsPerMinute < 5 ? '#f44336' : '#FF9800'
                });
            }
            
            // Top trending keywords
            if (metrics.keywordFrequency && Object.keys(metrics.keywordFrequency).length > 0) {
                const topKeywords = Object.entries(metrics.keywordFrequency)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 3)
                    .filter(([,count]) => count >= 2);
                
                if (topKeywords.length > 0) {
                    insights.push({
                        icon: '📈',
                        title: 'Trending Keywords',
                        content: topKeywords.map(([word, count]) => `${word} (${count})`).join(', '),
                        color: '#2196F3'
                    });
                }
            }
            
            // Clear existing content
            aiInsightsDiv.innerHTML = '';
            
            // Add insights
            insights.forEach(insight => {
                const item = document.createElement('div');
                item.className = 'feed-item';
                item.style.borderLeftColor = insight.color;
                
                item.innerHTML = `
                    <div class="feed-user">${insight.icon} ${insight.title}</div>
                    <div class="feed-content">${insight.content}</div>
                `;
                
                aiInsightsDiv.appendChild(item);
            });
            
            // If no insights, show default message
            if (insights.length === 0) {
                aiInsightsDiv.innerHTML = '<div class="feed-item">Analyzing chat data...</div>';
            }
        }
        
        // Update predictive analytics display with improved accuracy
        function updatePredictiveAnalytics(data) {
            if (!data.predictiveMetrics) return;
            
            const pm = data.predictiveMetrics;
            
            // Calculate more accurate predictive scores based on real-time data
            const improvedScores = calculateImprovedPredictiveScores(data);
            
            // Update churn risk with improved calculation
            const churnRiskEl = document.getElementById('churnRiskScore');
            const churnTrendEl = document.getElementById('churnRiskTrend');
            if (churnRiskEl) {
                const churnScore = improvedScores.churnRisk;
                churnRiskEl.textContent = `${Math.round(churnScore)}%`;
                churnRiskEl.style.color = getRiskColor(churnScore);
            }
            if (churnTrendEl) {
                churnTrendEl.textContent = getRiskTrend(improvedScores.churnRisk);
            }
            
            // Update monetization opportunity with improved calculation
            const monetizationEl = document.getElementById('monetizationScore');
            const monetizationTrendEl = document.getElementById('monetizationTrend');
            if (monetizationEl) {
                const monetizationScore = improvedScores.monetization;
                monetizationEl.textContent = `${Math.round(monetizationScore)}%`;
                monetizationEl.style.color = getOpportunityColor(monetizationScore);
            }
            if (monetizationTrendEl) {
                monetizationTrendEl.textContent = getOpportunityTrend(improvedScores.monetization);
            }
            
            // Update retention rate with improved calculation
            const retentionEl = document.getElementById('retentionRate');
            const retentionTrendEl = document.getElementById('retentionTrend');
            if (retentionEl) {
                const retentionScore = improvedScores.retention;
                retentionEl.textContent = `${Math.round(retentionScore * 100)}%`;
                retentionEl.style.color = getRetentionColor(retentionScore);
            }
            if (retentionTrendEl) {
                retentionTrendEl.textContent = getRetentionTrend(improvedScores.retention);
            }
            
            // Update sentiment volatility with improved calculation
            const volatilityEl = document.getElementById('sentimentVolatility');
            const volatilityTrendEl = document.getElementById('volatilityTrend');
            if (volatilityEl) {
                const volatilityScore = improvedScores.volatility;
                volatilityEl.textContent = volatilityScore.toFixed(2);
                volatilityEl.style.color = getVolatilityColor(volatilityScore);
            }
            if (volatilityTrendEl) {
                volatilityTrendEl.textContent = getVolatilityTrend(improvedScores.volatility);
            }
            
            // Update predictive insights with improved data
            updatePredictiveInsights(improvedScores, data);
        }

        // Calculate improved predictive scores based on real-time data patterns
        function calculateImprovedPredictiveScores(data) {
            // Get current activity data
            const currentViewers = parseInt(document.getElementById('viewerCount')?.textContent || '0');
            const currentLikes = parseInt(document.getElementById('totalLikes')?.textContent || '0');
            const currentGifts = parseInt(document.getElementById('totalGifts')?.textContent || '0');
            const currentShares = parseInt(document.getElementById('totalShares')?.textContent || '0');
            const likesPerMinute = parseInt(document.getElementById('likesPerMinute')?.textContent || '0');
            
            // Calculate engagement rate (likes + gifts + shares per viewer)
            const totalEngagement = currentLikes + (currentGifts * 10) + (currentShares * 5); // Weighted engagement
            const engagementRate = currentViewers > 0 ? totalEngagement / currentViewers : 0;
            
            // Calculate churn risk based on engagement patterns
            let churnRisk = 0;
            if (engagementRate < 2) churnRisk = 85; // High risk if low engagement
            else if (engagementRate < 5) churnRisk = 60; // Medium-high risk
            else if (engagementRate < 10) churnRisk = 35; // Medium risk
            else if (engagementRate < 20) churnRisk = 15; // Low risk
            else churnRisk = 5; // Very low risk
            
            // Adjust based on likes per minute trend
            if (likesPerMinute < 5) churnRisk += 10;
            else if (likesPerMinute > 20) churnRisk -= 10;
            
            // Calculate monetization opportunity based on gift patterns
            let monetization = 0;
            if (currentGifts > 0) {
                const giftRate = currentGifts / Math.max(currentViewers, 1);
                if (giftRate > 0.3) monetization = 90; // High opportunity
                else if (giftRate > 0.2) monetization = 75;
                else if (giftRate > 0.1) monetization = 60;
                else if (giftRate > 0.05) monetization = 45;
                else monetization = 30;
            } else {
                // No gifts yet, estimate based on engagement
                monetization = Math.min(engagementRate * 3, 50);
            }
            
            // Calculate retention based on viewer stability and engagement
            let retention = 0.5; // Base retention
            if (engagementRate > 15) retention += 0.3; // High engagement = better retention
            if (likesPerMinute > 15) retention += 0.2; // Active chat = better retention
            if (currentGifts > 0) retention += 0.1; // Gifts indicate strong connection
            
            // Calculate volatility based on engagement consistency
            let volatility = 1.0; // Base volatility
            if (engagementRate < 5) volatility += 0.5; // Low engagement = more volatile
            if (likesPerMinute < 10) volatility += 0.3; // Inactive periods = more volatile
            if (currentGifts === 0) volatility += 0.2; // No gifts = more volatile
            
            // Ensure scores are within valid ranges
            churnRisk = Math.max(0, Math.min(100, churnRisk));
            monetization = Math.max(0, Math.min(100, monetization));
            retention = Math.max(0.1, Math.min(1.0, retention));
            volatility = Math.max(0.5, Math.min(3.0, volatility));
            
            return {
                churnRisk: Math.round(churnRisk),
                monetization: Math.round(monetization),
                retention: retention,
                volatility: volatility
            };
        }
        
        // Helper functions for predictive analytics display
        function getRiskColor(score) {
            if (score >= 80) return '#ff4444';
            if (score >= 60) return '#ff8800';
            if (score >= 40) return '#ffaa00';
            return '#4CAF50';
        }

        function getRiskTrend(score) {
            if (score >= 80) return 'Critical';
            if (score >= 60) return 'High';
            if (score >= 40) return 'Medium';
            return 'Low';
        }

        function getOpportunityColor(score) {
            if (score >= 75) return '#4CAF50';
            if (score >= 50) return '#8BC34A';
            if (score >= 25) return '#FF9800';
            return '#9E9E9E';
        }

        function getOpportunityTrend(score) {
            if (score >= 75) return 'High';
            if (score >= 50) return 'Medium';
            if (score >= 25) return 'Low';
            return 'None';
        }

        function getRetentionColor(rate) {
            if (rate >= 0.8) return '#4CAF50';
            if (rate >= 0.6) return '#8BC34A';
            if (rate >= 0.4) return '#FF9800';
            return '#f44336';
        }

        function getRetentionTrend(rate) {
            if (rate >= 0.8) return 'Excellent';
            if (rate >= 0.6) return 'Good';
            if (rate >= 0.4) return 'Fair';
            return 'Poor';
        }

        function getVolatilityColor(volatility) {
            if (volatility >= 2.0) return '#f44336';
            if (volatility >= 1.5) return '#FF9800';
            if (volatility >= 1.0) return '#8BC34A';
            return '#4CAF50';
        }

        function getVolatilityTrend(volatility) {
            if (volatility >= 2.0) return 'High';
            if (volatility >= 1.5) return 'Medium';
            if (volatility >= 1.0) return 'Low';
            return 'Very Low';
        }

        function updatePredictiveInsights(predictiveMetrics) {
            const insightsDiv = document.getElementById('predictiveInsights');
            if (!insightsDiv) return;
            
            const insights = [];
            
            // Churn risk insights
            if (predictiveMetrics.churnRiskScore > 70) {
                insights.push(`<div class="feed-item" style="border-left: 4px solid #ff4444;">
                    <div class="feed-content">
                        🚨 <strong>High Churn Risk:</strong> ${predictiveMetrics.churnRiskScore}% risk of viewer loss. 
                        Consider immediate engagement strategies.
                    </div>
                </div>`);
            }
            
            // Monetization opportunities
            if (predictiveMetrics.monetizationOpportunityScore > 75) {
                insights.push(`<div class="feed-item" style="border-left: 4px solid #4CAF50;">
                    <div class="feed-content">
                        💰 <strong>Monetization Opportunity:</strong> ${predictiveMetrics.monetizationOpportunityScore}% opportunity score. 
                        Perfect time to encourage gifts/support.
                    </div>
                </div>`);
            }
            
            // Retention insights
            if (predictiveMetrics.viewerRetentionRate < 0.6) {
                insights.push(`<div class="feed-item" style="border-left: 4px solid #FF9800;">
                    <div class="feed-content">
                        📉 <strong>Retention Alert:</strong> Only ${Math.round(predictiveMetrics.viewerRetentionRate * 100)}% viewer retention. 
                        Consider addressing controversial topics carefully.
                    </div>
                </div>`);
            }
            
            // Sentiment volatility insights
            if (predictiveMetrics.sentimentVolatility > 1.5) {
                insights.push(`<div class="feed-item" style="border-left: 4px solid #FF9800;">
                    <div class="feed-content">
                        📊 <strong>Sentiment Volatility:</strong> High fluctuation in chat mood. 
                        Consider addressing controversial topics carefully.
                    </div>
                </div>`);
            }
            
            // Update display
            if (insights.length > 0) {
                insightsDiv.innerHTML = insights.join('');
            } else {
                insightsDiv.innerHTML = '<div class="feed-item">All metrics within normal ranges</div>';
            }
        }

        // Update actionable prompt display
        function updateActionablePrompt(prompt) {
            const promptElement = document.getElementById('actionablePrompt');
            if (!prompt || !promptElement) return;
            
            const promptContent = promptElement.querySelector('.prompt-content');
            const promptText = promptContent.querySelector('.prompt-text');
            const promptTrigger = promptElement.querySelector('.prompt-trigger');
            
            // Display the main prompt message
            promptText.textContent = prompt.message;
            promptText.className = 'prompt-text';
            
            // Show a user-friendly trigger description instead of technical names
            let triggerDescription = 'AI Assistant';
            if (prompt.trigger === 'engagement_decline') {
                triggerDescription = '📉 Engagement Alert';
            } else if (prompt.trigger === 'extended_silence') {
                triggerDescription = '🔇 Chat Activity';
            } else if (prompt.trigger === 'test_prompt') {
                triggerDescription = '💡 Suggestion';
            } else if (prompt.trigger === 'engagement_decline') {
                triggerDescription = '📊 Stream Health';
            }
            
            promptTrigger.textContent = triggerDescription;
            
            // Add priority-based styling
            promptElement.className = `actionable-prompt ${prompt.priority || 'medium'}-priority`;
            
            // Speak the prompt using TTS if enabled
            if (ttsEnabled && prompt.message) {
                speakText(prompt.message, prompt.priority || 'medium');
            }
            
            console.log('🎯 Updated actionable prompt:', prompt.message);
        }
        
        // Add prompt to history with user-friendly display
        function addToPromptHistory(prompt) {
            const historyElement = document.getElementById('promptHistory');
            if (!historyElement || !prompt) return;
            
            const time = new Date().toLocaleTimeString();
            
            // Create user-friendly trigger description
            let triggerDescription = 'AI Suggestion';
            if (prompt.trigger === 'engagement_decline') {
                triggerDescription = '📉 Engagement Alert';
            } else if (prompt.trigger === 'extended_silence') {
                triggerDescription = '🔇 Chat Activity';
            } else if (prompt.trigger === 'test_prompt') {
                triggerDescription = '💡 General Suggestion';
            } else if (prompt.trigger === 'engagement_decline') {
                triggerDescription = '📊 Stream Health';
            }
            
            const historyItem = document.createElement('div');
            historyItem.className = 'feed-item';
            historyItem.innerHTML = `
                <div class="feed-content">
                    <div class="prompt-history-message">${prompt.message}</div>
                    <div class="prompt-history-trigger">${triggerDescription}</div>
                </div>
                <div class="feed-time">${time}</div>
            `;
            
            // Insert at the top
            historyElement.insertBefore(historyItem, historyElement.firstChild);
            
            // Keep only last 10 prompts
            while (historyElement.children.length > 10) {
                historyElement.removeChild(historyElement.lastChild);
            }
        }
        
        // Check for automated prompts based on metrics
        function checkForAutomatedPrompts(metrics) {
            if (!metrics) return;
            
            const prompts = [];
            
            // Low engagement detection
            if (metrics.commentsPerMinute < 5 && metrics.totalComments > 50) {
                prompts.push({
                    message: '💬 Comment volume is low! Try asking viewers a question or starting a conversation!',
                    trigger: 'low_engagement',
                    priority: 'high'
                });
            }
            
            // Negative sentiment detection
            if (metrics.rollingSentimentScore < -0.3) {
                prompts.push({
                    message: '😔 Sentiment is trending negative. Consider changing topics or telling a joke!',
                    trigger: 'negative_sentiment',
                    priority: 'high'
                });
            }
            
            // High engagement celebration
            if (metrics.commentsPerMinute > 20) {
                prompts.push({
                    message: '🔥 Amazing engagement! Keep the energy up!',
                    trigger: 'high_engagement',
                    priority: 'medium'
                });
            }
            
            // Viewer milestone celebration
            if (metrics.currentViewerCount > 1000 && metrics.currentViewerCount % 500 === 0) {
                prompts.push({
                    message: `🎉 ${metrics.currentViewerCount.toLocaleString()} viewers! Amazing milestone!`,
                    trigger: 'viewer_milestone',
                    priority: 'medium'
                });
            }
            
            // Like engagement encouragement
            if (metrics.likesPerMinute < 10 && metrics.totalLikes > 100) {
                prompts.push({
                    message: '❤️ Ask viewers to show some love with likes!',
                    trigger: 'low_likes',
                    priority: 'medium'
                });
            }
            
            // Return highest priority prompt
            const highPriorityPrompts = prompts.filter(p => p.priority === 'high');
            const mediumPriorityPrompts = prompts.filter(p => p.priority === 'medium');
            
            if (highPriorityPrompts.length > 0) {
                updateActionablePrompt(highPriorityPrompts[0]);
            } else if (mediumPriorityPrompts.length > 0) {
                updateActionablePrompt(mediumPriorityPrompts[0]);
            }
            
            // Speak the first prompt if TTS is enabled
            if (ttsEnabled && prompts.length > 0) {
                const firstPrompt = prompts[0];
                speakText(firstPrompt.message, firstPrompt.priority || 'medium');
            }
        }



        // Test WebSocket connection
        function testWebSocketConnection() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log('🧪 Testing WebSocket connection...');
                ws.send(JSON.stringify({ type: 'test', data: 'ping' }));
                return true;
            } else {
                console.warn('⚠️  WebSocket not connected, cannot test');
                return false;
            }
        }

        // Manual reconnect function
        function manualReconnect() {
            console.log('🔄 Manually initiating WebSocket reconnection...');
            updateConnectionStatus('Reconnecting...', '');
            reconnectAttempts = 0; // Reset reconnect attempts
            connectWebSocket();
        }

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            // Enable mobile optimizations first
            enableMobileOptimizations();
            
            // Restore connection state from localStorage
            restoreConnectionState();
            
            connectWebSocket(); // Changed from initWebSocket()
            
            // Add initial activity item
            addActivityItem('🚀', 'System', 'Dashboard initialized');
            
            // Test WebSocket connection every 30 seconds to keep it alive
            setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    testWebSocketConnection();
                }
            }, 30000);
            
            // Update connection duration every second when connected
            setInterval(() => {
                const savedState = loadConnectionState();
                if (savedState && savedState.isConnected && savedState.username) {
                    updateConnectionDetails(savedState.username);
                }
            }, 1000);
            
            // Start activity cleanup system for performance optimization
            startActivityCleanup();
            
            // Initialize TTS functionality
            initializeTTS();
        });
        
        // Text-to-Speech (TTS) Functionality
        let ttsEnabled = false;
        let speechSynthesis = null;
        let currentUtterance = null;
        
        function initializeTTS() {
            // Check if speech synthesis is supported
            if ('speechSynthesis' in window) {
                speechSynthesis = window.speechSynthesis;
                loadTTSVoices();
                
                // Set up TTS toggle button
                const ttsToggle = document.getElementById('ttsToggle');
                if (ttsToggle) {
                    ttsToggle.addEventListener('click', toggleTTS);
                }
                
                // Set up TTS settings controls
                setupTTSSettings();
                
                // Load TTS preferences from localStorage
                loadTTSPreferences();
                
                // Add keyboard shortcut (Ctrl+Shift+T) for TTS toggle
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                        e.preventDefault();
                        toggleTTS();
                    }
                });
                
                console.log('🔊 TTS initialized successfully');
            } else {
                console.warn('⚠️ Speech synthesis not supported in this browser');
                disableTTSControls();
            }
        }
        
        function loadTTSVoices() {
            if (!speechSynthesis) return;
            
            const voiceSelect = document.getElementById('ttsVoice');
            if (!voiceSelect) return;
            
            // Load voices when they become available
            const loadVoices = () => {
                const voices = speechSynthesis.getVoices();
                voiceSelect.innerHTML = '';
                
                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Select Voice';
                voiceSelect.appendChild(defaultOption);
                
                // Add available voices
                voices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.name;
                    option.textContent = `${voice.name} (${voice.lang})`;
                    voiceSelect.appendChild(option);
                });
                
                // Restore selected voice from preferences
                const preferences = loadTTSPreferences();
                if (preferences.voice && voices.find(v => v.name === preferences.voice)) {
                    voiceSelect.value = preferences.voice;
                }
            };
            
            // Load voices immediately if available
            if (speechSynthesis.getVoices().length > 0) {
                loadVoices();
            } else {
                // Wait for voices to load
                speechSynthesis.addEventListener('voiceschanged', loadVoices);
            }
        }
        
        function setupTTSSettings() {
            const voiceSelect = document.getElementById('ttsVoice');
            const speedSlider = document.getElementById('ttsSpeed');
            const volumeSlider = document.getElementById('ttsVolume');
            const speedValue = document.getElementById('ttsSpeedValue');
            const volumeValue = document.getElementById('ttsVolumeValue');
            
            if (voiceSelect) {
                voiceSelect.addEventListener('change', (e) => {
                    saveTTSPreferences();
                });
            }
            
            if (speedSlider && speedValue) {
                speedSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    speedValue.textContent = `${value.toFixed(1)}x`;
                    saveTTSPreferences();
                });
            }
            
            if (volumeSlider && volumeValue) {
                volumeSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    volumeValue.textContent = `${Math.round(value * 100)}%`;
                    saveTTSPreferences();
                });
            }
        }
        
        function toggleTTS() {
            ttsEnabled = !ttsEnabled;
            const ttsToggle = document.getElementById('ttsToggle');
            const ttsStatus = document.getElementById('ttsStatus');
            const ttsSettings = document.getElementById('ttsSettings');
            
            if (ttsToggle && ttsStatus) {
                if (ttsEnabled) {
                    ttsToggle.classList.add('active');
                    ttsStatus.textContent = 'ON';
                    ttsSettings.classList.add('visible');
                    console.log('🔊 TTS enabled');
                } else {
                    ttsToggle.classList.remove('active');
                    ttsStatus.textContent = 'OFF';
                    ttsSettings.classList.remove('visible');
                    stopTTS();
                    console.log('🔇 TTS disabled');
                }
            }
            
            saveTTSPreferences();
        }
        
        function speakText(text, priority = 'medium') {
            if (!ttsEnabled || !speechSynthesis || !text) return;
            
            // Stop any current speech
            stopTTS();
            
            // Create new utterance
            currentUtterance = new SpeechSynthesisUtterance(text);
            
            // Get TTS preferences
            const preferences = loadTTSPreferences();
            
            // Set voice
            if (preferences.voice) {
                const voices = speechSynthesis.getVoices();
                const selectedVoice = voices.find(v => v.name === preferences.voice);
                if (selectedVoice) {
                    currentUtterance.voice = selectedVoice;
                }
            }
            
            // Set speed and volume
            currentUtterance.rate = preferences.speed || 1;
            currentUtterance.volume = preferences.volume || 0.8;
            
            // Set pitch based on priority
            if (priority === 'high') {
                currentUtterance.pitch = 1.2; // Higher pitch for high priority
            } else if (priority === 'low') {
                currentUtterance.pitch = 0.8; // Lower pitch for low priority
            } else {
                currentUtterance.pitch = 1.0; // Normal pitch for medium priority
            }
            
            // Add event listeners
            currentUtterance.onstart = () => {
                console.log('🔊 TTS started:', text.substring(0, 50) + '...');
                showSpeakingIndicator();
            };
            
            currentUtterance.onend = () => {
                console.log('🔊 TTS completed');
                currentUtterance = null;
                hideSpeakingIndicator();
            };
            
            currentUtterance.onerror = (event) => {
                console.error('🔊 TTS error:', event.error);
                currentUtterance = null;
                hideSpeakingIndicator();
            };
            
            // Speak the text
            speechSynthesis.speak(currentUtterance);
        }
        
        function stopTTS() {
            if (speechSynthesis && currentUtterance) {
                speechSynthesis.cancel();
                currentUtterance = null;
            }
            hideSpeakingIndicator();
        }
        
        function showSpeakingIndicator() {
            const indicator = document.getElementById('ttsSpeakingIndicator');
            if (indicator) {
                indicator.classList.remove('hidden');
            }
        }
        
        function hideSpeakingIndicator() {
            const indicator = document.getElementById('ttsSpeakingIndicator');
            if (indicator) {
                indicator.classList.add('hidden');
            }
        }
        
        function loadTTSPreferences() {
            try {
                const saved = localStorage.getItem('ttsPreferences');
                const preferences = saved ? JSON.parse(saved) : {
                    voice: '',
                    speed: 1,
                    volume: 0.8
                };
                
                // Update display values
                const speedValue = document.getElementById('ttsSpeedValue');
                const volumeValue = document.getElementById('ttsVolumeValue');
                const speedSlider = document.getElementById('ttsSpeed');
                const volumeSlider = document.getElementById('ttsVolume');
                
                if (speedValue && speedSlider) {
                    speedSlider.value = preferences.speed;
                    speedValue.textContent = `${preferences.speed.toFixed(1)}x`;
                }
                
                if (volumeValue && volumeSlider) {
                    volumeSlider.value = preferences.volume;
                    volumeValue.textContent = `${Math.round(preferences.volume * 100)}%`;
                }
                
                return preferences;
            } catch (error) {
                console.error('Error loading TTS preferences:', error);
                return {
                    voice: '',
                    speed: 1,
                    volume: 0.8
                };
            }
        }
        
        function saveTTSPreferences() {
            try {
                const voiceSelect = document.getElementById('ttsVoice');
                const speedSlider = document.getElementById('ttsSpeed');
                const volumeSlider = document.getElementById('ttsVolume');
                
                const preferences = {
                    voice: voiceSelect ? voiceSelect.value : '',
                    speed: speedSlider ? parseFloat(speedSlider.value) : 1,
                    volume: volumeSlider ? parseFloat(volumeSlider.value) : 0.8
                };
                
                localStorage.setItem('ttsPreferences', JSON.stringify(preferences));
            } catch (error) {
                console.error('Error saving TTS preferences:', error);
            }
        }
        
        function disableTTSControls() {
            const ttsToggle = document.getElementById('ttsToggle');
            const ttsSettings = document.getElementById('ttsSettings');
            
            if (ttsToggle) {
                ttsToggle.disabled = true;
                ttsToggle.title = 'TTS not supported in this browser';
            }
            
            if (ttsSettings) {
                ttsSettings.style.display = 'none';
            }
        }
        
        // Additional TTS helper functions
        function speakWelcome(viewerName) {
            if (!ttsEnabled) {
                alert('Please enable TTS first using the 🔊 button in the LIVE ASSISTANT section.');
                return;
            }
            
            const welcomeMessage = `Welcome ${viewerName}! Thank you for joining the stream!`;
            speakText(welcomeMessage, 'medium');
        }
        
        function speakEmergency(message) {
            if (ttsEnabled) {
                speakText(`EMERGENCY: ${message}`, 'high');
            }
        }
        
        function speakMilestone(message) {
            if (ttsEnabled) {
                speakText(`Milestone achieved: ${message}`, 'medium');
            }
        }
    </script>
</body>
</html>

            